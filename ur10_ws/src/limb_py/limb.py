# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _limb_py
else:
    import _limb_py

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _limb_py.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _limb_py.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _limb_py.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _limb_py.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _limb_py.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _limb_py.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _limb_py.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _limb_py.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _limb_py.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _limb_py.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _limb_py.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _limb_py.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _limb_py.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _limb_py.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _limb_py.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _limb_py.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _limb_py.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _limb_py:
_limb_py.SwigPyIterator_swigregister(SwigPyIterator)

SHARED_PTR_DISOWN = _limb_py.SHARED_PTR_DISOWN
class IntVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.IntVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _limb_py.IntVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _limb_py.IntVector___bool__(self)

    def __len__(self) -> "std::vector< int >::size_type":
        return _limb_py.IntVector___len__(self)

    def __getslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "std::vector< int,std::allocator< int > > *":
        return _limb_py.IntVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _limb_py.IntVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< int >::difference_type", j: "std::vector< int >::difference_type") -> "void":
        return _limb_py.IntVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _limb_py.IntVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< int >::value_type const &":
        return _limb_py.IntVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _limb_py.IntVector___setitem__(self, *args)

    def pop(self) -> "std::vector< int >::value_type":
        return _limb_py.IntVector_pop(self)

    def append(self, x: "std::vector< int >::value_type const &") -> "void":
        return _limb_py.IntVector_append(self, x)

    def empty(self) -> "bool":
        return _limb_py.IntVector_empty(self)

    def size(self) -> "std::vector< int >::size_type":
        return _limb_py.IntVector_size(self)

    def swap(self, v: "IntVector") -> "void":
        return _limb_py.IntVector_swap(self, v)

    def begin(self) -> "std::vector< int >::iterator":
        return _limb_py.IntVector_begin(self)

    def end(self) -> "std::vector< int >::iterator":
        return _limb_py.IntVector_end(self)

    def rbegin(self) -> "std::vector< int >::reverse_iterator":
        return _limb_py.IntVector_rbegin(self)

    def rend(self) -> "std::vector< int >::reverse_iterator":
        return _limb_py.IntVector_rend(self)

    def clear(self) -> "void":
        return _limb_py.IntVector_clear(self)

    def get_allocator(self) -> "std::vector< int >::allocator_type":
        return _limb_py.IntVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _limb_py.IntVector_pop_back(self)

    def erase(self, *args) -> "std::vector< int >::iterator":
        return _limb_py.IntVector_erase(self, *args)

    def __init__(self, *args):
        _limb_py.IntVector_swiginit(self, _limb_py.new_IntVector(*args))

    def push_back(self, x: "std::vector< int >::value_type const &") -> "void":
        return _limb_py.IntVector_push_back(self, x)

    def front(self) -> "std::vector< int >::value_type const &":
        return _limb_py.IntVector_front(self)

    def back(self) -> "std::vector< int >::value_type const &":
        return _limb_py.IntVector_back(self)

    def assign(self, n: "std::vector< int >::size_type", x: "std::vector< int >::value_type const &") -> "void":
        return _limb_py.IntVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _limb_py.IntVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _limb_py.IntVector_insert(self, *args)

    def reserve(self, n: "std::vector< int >::size_type") -> "void":
        return _limb_py.IntVector_reserve(self, n)

    def capacity(self) -> "std::vector< int >::size_type":
        return _limb_py.IntVector_capacity(self)
    __swig_destroy__ = _limb_py.delete_IntVector

# Register IntVector in _limb_py:
_limb_py.IntVector_swigregister(IntVector)

class DoubleVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.DoubleVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _limb_py.DoubleVector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _limb_py.DoubleVector___bool__(self)

    def __len__(self) -> "std::vector< double >::size_type":
        return _limb_py.DoubleVector___len__(self)

    def __getslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "std::vector< double,std::allocator< double > > *":
        return _limb_py.DoubleVector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _limb_py.DoubleVector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< double >::difference_type", j: "std::vector< double >::difference_type") -> "void":
        return _limb_py.DoubleVector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _limb_py.DoubleVector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< double >::value_type const &":
        return _limb_py.DoubleVector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _limb_py.DoubleVector___setitem__(self, *args)

    def pop(self) -> "std::vector< double >::value_type":
        return _limb_py.DoubleVector_pop(self)

    def append(self, x: "std::vector< double >::value_type const &") -> "void":
        return _limb_py.DoubleVector_append(self, x)

    def empty(self) -> "bool":
        return _limb_py.DoubleVector_empty(self)

    def size(self) -> "std::vector< double >::size_type":
        return _limb_py.DoubleVector_size(self)

    def swap(self, v: "DoubleVector") -> "void":
        return _limb_py.DoubleVector_swap(self, v)

    def begin(self) -> "std::vector< double >::iterator":
        return _limb_py.DoubleVector_begin(self)

    def end(self) -> "std::vector< double >::iterator":
        return _limb_py.DoubleVector_end(self)

    def rbegin(self) -> "std::vector< double >::reverse_iterator":
        return _limb_py.DoubleVector_rbegin(self)

    def rend(self) -> "std::vector< double >::reverse_iterator":
        return _limb_py.DoubleVector_rend(self)

    def clear(self) -> "void":
        return _limb_py.DoubleVector_clear(self)

    def get_allocator(self) -> "std::vector< double >::allocator_type":
        return _limb_py.DoubleVector_get_allocator(self)

    def pop_back(self) -> "void":
        return _limb_py.DoubleVector_pop_back(self)

    def erase(self, *args) -> "std::vector< double >::iterator":
        return _limb_py.DoubleVector_erase(self, *args)

    def __init__(self, *args):
        _limb_py.DoubleVector_swiginit(self, _limb_py.new_DoubleVector(*args))

    def push_back(self, x: "std::vector< double >::value_type const &") -> "void":
        return _limb_py.DoubleVector_push_back(self, x)

    def front(self) -> "std::vector< double >::value_type const &":
        return _limb_py.DoubleVector_front(self)

    def back(self) -> "std::vector< double >::value_type const &":
        return _limb_py.DoubleVector_back(self)

    def assign(self, n: "std::vector< double >::size_type", x: "std::vector< double >::value_type const &") -> "void":
        return _limb_py.DoubleVector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _limb_py.DoubleVector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _limb_py.DoubleVector_insert(self, *args)

    def reserve(self, n: "std::vector< double >::size_type") -> "void":
        return _limb_py.DoubleVector_reserve(self, n)

    def capacity(self) -> "std::vector< double >::size_type":
        return _limb_py.DoubleVector_capacity(self)
    __swig_destroy__ = _limb_py.delete_DoubleVector

# Register DoubleVector in _limb_py:
_limb_py.DoubleVector_swigregister(DoubleVector)

class stringvector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.stringvector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _limb_py.stringvector___nonzero__(self)

    def __bool__(self) -> "bool":
        return _limb_py.stringvector___bool__(self)

    def __len__(self) -> "std::vector< std::string >::size_type":
        return _limb_py.stringvector___len__(self)

    def __getslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "std::vector< std::string,std::allocator< std::string > > *":
        return _limb_py.stringvector___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _limb_py.stringvector___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::string >::difference_type", j: "std::vector< std::string >::difference_type") -> "void":
        return _limb_py.stringvector___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _limb_py.stringvector___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::string >::value_type const &":
        return _limb_py.stringvector___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _limb_py.stringvector___setitem__(self, *args)

    def pop(self) -> "std::vector< std::string >::value_type":
        return _limb_py.stringvector_pop(self)

    def append(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _limb_py.stringvector_append(self, x)

    def empty(self) -> "bool":
        return _limb_py.stringvector_empty(self)

    def size(self) -> "std::vector< std::string >::size_type":
        return _limb_py.stringvector_size(self)

    def swap(self, v: "stringvector") -> "void":
        return _limb_py.stringvector_swap(self, v)

    def begin(self) -> "std::vector< std::string >::iterator":
        return _limb_py.stringvector_begin(self)

    def end(self) -> "std::vector< std::string >::iterator":
        return _limb_py.stringvector_end(self)

    def rbegin(self) -> "std::vector< std::string >::reverse_iterator":
        return _limb_py.stringvector_rbegin(self)

    def rend(self) -> "std::vector< std::string >::reverse_iterator":
        return _limb_py.stringvector_rend(self)

    def clear(self) -> "void":
        return _limb_py.stringvector_clear(self)

    def get_allocator(self) -> "std::vector< std::string >::allocator_type":
        return _limb_py.stringvector_get_allocator(self)

    def pop_back(self) -> "void":
        return _limb_py.stringvector_pop_back(self)

    def erase(self, *args) -> "std::vector< std::string >::iterator":
        return _limb_py.stringvector_erase(self, *args)

    def __init__(self, *args):
        _limb_py.stringvector_swiginit(self, _limb_py.new_stringvector(*args))

    def push_back(self, x: "std::vector< std::string >::value_type const &") -> "void":
        return _limb_py.stringvector_push_back(self, x)

    def front(self) -> "std::vector< std::string >::value_type const &":
        return _limb_py.stringvector_front(self)

    def back(self) -> "std::vector< std::string >::value_type const &":
        return _limb_py.stringvector_back(self)

    def assign(self, n: "std::vector< std::string >::size_type", x: "std::vector< std::string >::value_type const &") -> "void":
        return _limb_py.stringvector_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _limb_py.stringvector_resize(self, *args)

    def insert(self, *args) -> "void":
        return _limb_py.stringvector_insert(self, *args)

    def reserve(self, n: "std::vector< std::string >::size_type") -> "void":
        return _limb_py.stringvector_reserve(self, n)

    def capacity(self) -> "std::vector< std::string >::size_type":
        return _limb_py.stringvector_capacity(self)
    __swig_destroy__ = _limb_py.delete_stringvector

# Register stringvector in _limb_py:
_limb_py.stringvector_swigregister(stringvector)

class vector_vector_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.vector_vector_double_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _limb_py.vector_vector_double___nonzero__(self)

    def __bool__(self) -> "bool":
        return _limb_py.vector_vector_double___bool__(self)

    def __len__(self) -> "std::vector< std::vector< double > >::size_type":
        return _limb_py.vector_vector_double___len__(self)

    def __getslice__(self, i: "std::vector< std::vector< double > >::difference_type", j: "std::vector< std::vector< double > >::difference_type") -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > > *":
        return _limb_py.vector_vector_double___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _limb_py.vector_vector_double___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< std::vector< double > >::difference_type", j: "std::vector< std::vector< double > >::difference_type") -> "void":
        return _limb_py.vector_vector_double___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _limb_py.vector_vector_double___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< std::vector< double > >::value_type const &":
        return _limb_py.vector_vector_double___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _limb_py.vector_vector_double___setitem__(self, *args)

    def pop(self) -> "std::vector< std::vector< double > >::value_type":
        return _limb_py.vector_vector_double_pop(self)

    def append(self, x: "DoubleVector") -> "void":
        return _limb_py.vector_vector_double_append(self, x)

    def empty(self) -> "bool":
        return _limb_py.vector_vector_double_empty(self)

    def size(self) -> "std::vector< std::vector< double > >::size_type":
        return _limb_py.vector_vector_double_size(self)

    def swap(self, v: "vector_vector_double") -> "void":
        return _limb_py.vector_vector_double_swap(self, v)

    def begin(self) -> "std::vector< std::vector< double > >::iterator":
        return _limb_py.vector_vector_double_begin(self)

    def end(self) -> "std::vector< std::vector< double > >::iterator":
        return _limb_py.vector_vector_double_end(self)

    def rbegin(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        return _limb_py.vector_vector_double_rbegin(self)

    def rend(self) -> "std::vector< std::vector< double > >::reverse_iterator":
        return _limb_py.vector_vector_double_rend(self)

    def clear(self) -> "void":
        return _limb_py.vector_vector_double_clear(self)

    def get_allocator(self) -> "std::vector< std::vector< double > >::allocator_type":
        return _limb_py.vector_vector_double_get_allocator(self)

    def pop_back(self) -> "void":
        return _limb_py.vector_vector_double_pop_back(self)

    def erase(self, *args) -> "std::vector< std::vector< double > >::iterator":
        return _limb_py.vector_vector_double_erase(self, *args)

    def __init__(self, *args):
        _limb_py.vector_vector_double_swiginit(self, _limb_py.new_vector_vector_double(*args))

    def push_back(self, x: "DoubleVector") -> "void":
        return _limb_py.vector_vector_double_push_back(self, x)

    def front(self) -> "std::vector< std::vector< double > >::value_type const &":
        return _limb_py.vector_vector_double_front(self)

    def back(self) -> "std::vector< std::vector< double > >::value_type const &":
        return _limb_py.vector_vector_double_back(self)

    def assign(self, n: "std::vector< std::vector< double > >::size_type", x: "DoubleVector") -> "void":
        return _limb_py.vector_vector_double_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _limb_py.vector_vector_double_resize(self, *args)

    def insert(self, *args) -> "void":
        return _limb_py.vector_vector_double_insert(self, *args)

    def reserve(self, n: "std::vector< std::vector< double > >::size_type") -> "void":
        return _limb_py.vector_vector_double_reserve(self, n)

    def capacity(self) -> "std::vector< std::vector< double > >::size_type":
        return _limb_py.vector_vector_double_capacity(self)
    __swig_destroy__ = _limb_py.delete_vector_vector_double

# Register vector_vector_double in _limb_py:
_limb_py.vector_vector_double_swigregister(vector_vector_double)

class vector_vectorxd(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.vector_vectorxd_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _limb_py.vector_vectorxd___nonzero__(self)

    def __bool__(self) -> "bool":
        return _limb_py.vector_vectorxd___bool__(self)

    def __len__(self) -> "std::vector< Eigen::VectorXd >::size_type":
        return _limb_py.vector_vectorxd___len__(self)

    def __getslice__(self, i: "std::vector< Eigen::VectorXd >::difference_type", j: "std::vector< Eigen::VectorXd >::difference_type") -> "std::vector< Eigen::VectorXd,std::allocator< Eigen::VectorXd > > *":
        return _limb_py.vector_vectorxd___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _limb_py.vector_vectorxd___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Eigen::VectorXd >::difference_type", j: "std::vector< Eigen::VectorXd >::difference_type") -> "void":
        return _limb_py.vector_vectorxd___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _limb_py.vector_vectorxd___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Eigen::VectorXd >::value_type const &":
        return _limb_py.vector_vectorxd___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _limb_py.vector_vectorxd___setitem__(self, *args)

    def pop(self) -> "std::vector< Eigen::VectorXd >::value_type":
        return _limb_py.vector_vectorxd_pop(self)

    def append(self, x: "std::vector< Eigen::VectorXd >::value_type const &") -> "void":
        return _limb_py.vector_vectorxd_append(self, x)

    def empty(self) -> "bool":
        return _limb_py.vector_vectorxd_empty(self)

    def size(self) -> "std::vector< Eigen::VectorXd >::size_type":
        return _limb_py.vector_vectorxd_size(self)

    def swap(self, v: "vector_vectorxd") -> "void":
        return _limb_py.vector_vectorxd_swap(self, v)

    def begin(self) -> "std::vector< Eigen::VectorXd >::iterator":
        return _limb_py.vector_vectorxd_begin(self)

    def end(self) -> "std::vector< Eigen::VectorXd >::iterator":
        return _limb_py.vector_vectorxd_end(self)

    def rbegin(self) -> "std::vector< Eigen::VectorXd >::reverse_iterator":
        return _limb_py.vector_vectorxd_rbegin(self)

    def rend(self) -> "std::vector< Eigen::VectorXd >::reverse_iterator":
        return _limb_py.vector_vectorxd_rend(self)

    def clear(self) -> "void":
        return _limb_py.vector_vectorxd_clear(self)

    def get_allocator(self) -> "std::vector< Eigen::VectorXd >::allocator_type":
        return _limb_py.vector_vectorxd_get_allocator(self)

    def pop_back(self) -> "void":
        return _limb_py.vector_vectorxd_pop_back(self)

    def erase(self, *args) -> "std::vector< Eigen::VectorXd >::iterator":
        return _limb_py.vector_vectorxd_erase(self, *args)

    def __init__(self, *args):
        _limb_py.vector_vectorxd_swiginit(self, _limb_py.new_vector_vectorxd(*args))

    def push_back(self, x: "std::vector< Eigen::VectorXd >::value_type const &") -> "void":
        return _limb_py.vector_vectorxd_push_back(self, x)

    def front(self) -> "std::vector< Eigen::VectorXd >::value_type const &":
        return _limb_py.vector_vectorxd_front(self)

    def back(self) -> "std::vector< Eigen::VectorXd >::value_type const &":
        return _limb_py.vector_vectorxd_back(self)

    def assign(self, n: "std::vector< Eigen::VectorXd >::size_type", x: "std::vector< Eigen::VectorXd >::value_type const &") -> "void":
        return _limb_py.vector_vectorxd_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _limb_py.vector_vectorxd_resize(self, *args)

    def insert(self, *args) -> "void":
        return _limb_py.vector_vectorxd_insert(self, *args)

    def reserve(self, n: "std::vector< Eigen::VectorXd >::size_type") -> "void":
        return _limb_py.vector_vectorxd_reserve(self, n)

    def capacity(self) -> "std::vector< Eigen::VectorXd >::size_type":
        return _limb_py.vector_vectorxd_capacity(self)
    __swig_destroy__ = _limb_py.delete_vector_vectorxd

# Register vector_vectorxd in _limb_py:
_limb_py.vector_vectorxd_swigregister(vector_vectorxd)

class vector_vector3d(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.vector_vector3d_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _limb_py.vector_vector3d___nonzero__(self)

    def __bool__(self) -> "bool":
        return _limb_py.vector_vector3d___bool__(self)

    def __len__(self) -> "std::vector< Eigen::Vector3d >::size_type":
        return _limb_py.vector_vector3d___len__(self)

    def __getslice__(self, i: "std::vector< Eigen::Vector3d >::difference_type", j: "std::vector< Eigen::Vector3d >::difference_type") -> "std::vector< Eigen::Vector3d,std::allocator< Eigen::Vector3d > > *":
        return _limb_py.vector_vector3d___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _limb_py.vector_vector3d___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< Eigen::Vector3d >::difference_type", j: "std::vector< Eigen::Vector3d >::difference_type") -> "void":
        return _limb_py.vector_vector3d___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _limb_py.vector_vector3d___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< Eigen::Vector3d >::value_type const &":
        return _limb_py.vector_vector3d___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _limb_py.vector_vector3d___setitem__(self, *args)

    def pop(self) -> "std::vector< Eigen::Vector3d >::value_type":
        return _limb_py.vector_vector3d_pop(self)

    def append(self, x: "std::vector< Eigen::Vector3d >::value_type const &") -> "void":
        return _limb_py.vector_vector3d_append(self, x)

    def empty(self) -> "bool":
        return _limb_py.vector_vector3d_empty(self)

    def size(self) -> "std::vector< Eigen::Vector3d >::size_type":
        return _limb_py.vector_vector3d_size(self)

    def swap(self, v: "vector_vector3d") -> "void":
        return _limb_py.vector_vector3d_swap(self, v)

    def begin(self) -> "std::vector< Eigen::Vector3d >::iterator":
        return _limb_py.vector_vector3d_begin(self)

    def end(self) -> "std::vector< Eigen::Vector3d >::iterator":
        return _limb_py.vector_vector3d_end(self)

    def rbegin(self) -> "std::vector< Eigen::Vector3d >::reverse_iterator":
        return _limb_py.vector_vector3d_rbegin(self)

    def rend(self) -> "std::vector< Eigen::Vector3d >::reverse_iterator":
        return _limb_py.vector_vector3d_rend(self)

    def clear(self) -> "void":
        return _limb_py.vector_vector3d_clear(self)

    def get_allocator(self) -> "std::vector< Eigen::Vector3d >::allocator_type":
        return _limb_py.vector_vector3d_get_allocator(self)

    def pop_back(self) -> "void":
        return _limb_py.vector_vector3d_pop_back(self)

    def erase(self, *args) -> "std::vector< Eigen::Vector3d >::iterator":
        return _limb_py.vector_vector3d_erase(self, *args)

    def __init__(self, *args):
        _limb_py.vector_vector3d_swiginit(self, _limb_py.new_vector_vector3d(*args))

    def push_back(self, x: "std::vector< Eigen::Vector3d >::value_type const &") -> "void":
        return _limb_py.vector_vector3d_push_back(self, x)

    def front(self) -> "std::vector< Eigen::Vector3d >::value_type const &":
        return _limb_py.vector_vector3d_front(self)

    def back(self) -> "std::vector< Eigen::Vector3d >::value_type const &":
        return _limb_py.vector_vector3d_back(self)

    def assign(self, n: "std::vector< Eigen::Vector3d >::size_type", x: "std::vector< Eigen::Vector3d >::value_type const &") -> "void":
        return _limb_py.vector_vector3d_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _limb_py.vector_vector3d_resize(self, *args)

    def insert(self, *args) -> "void":
        return _limb_py.vector_vector3d_insert(self, *args)

    def reserve(self, n: "std::vector< Eigen::Vector3d >::size_type") -> "void":
        return _limb_py.vector_vector3d_reserve(self, n)

    def capacity(self) -> "std::vector< Eigen::Vector3d >::size_type":
        return _limb_py.vector_vector3d_capacity(self)
    __swig_destroy__ = _limb_py.delete_vector_vector3d

# Register vector_vector3d in _limb_py:
_limb_py.vector_vector3d_swigregister(vector_vector3d)

class Str2LimbMap(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.Str2LimbMap_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _limb_py.Str2LimbMap___nonzero__(self)

    def __bool__(self) -> "bool":
        return _limb_py.Str2LimbMap___bool__(self)

    def __len__(self) -> "std::map< std::string,std::shared_ptr< Limb > >::size_type":
        return _limb_py.Str2LimbMap___len__(self)
    def __iter__(self):
        return self.key_iterator()
    def iterkeys(self):
        return self.key_iterator()
    def itervalues(self):
        return self.value_iterator()
    def iteritems(self):
        return self.iterator()

    def __getitem__(self, key: "std::map< std::string,std::shared_ptr< Limb > >::key_type const &") -> "std::map< std::string,std::shared_ptr< Limb > >::mapped_type const &":
        return _limb_py.Str2LimbMap___getitem__(self, key)

    def __delitem__(self, key: "std::map< std::string,std::shared_ptr< Limb > >::key_type const &") -> "void":
        return _limb_py.Str2LimbMap___delitem__(self, key)

    def has_key(self, key: "std::map< std::string,std::shared_ptr< Limb > >::key_type const &") -> "bool":
        return _limb_py.Str2LimbMap_has_key(self, key)

    def keys(self) -> "PyObject *":
        return _limb_py.Str2LimbMap_keys(self)

    def values(self) -> "PyObject *":
        return _limb_py.Str2LimbMap_values(self)

    def items(self) -> "PyObject *":
        return _limb_py.Str2LimbMap_items(self)

    def __contains__(self, key: "std::map< std::string,std::shared_ptr< Limb > >::key_type const &") -> "bool":
        return _limb_py.Str2LimbMap___contains__(self, key)

    def key_iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.Str2LimbMap_key_iterator(self)

    def value_iterator(self) -> "swig::SwigPyIterator *":
        return _limb_py.Str2LimbMap_value_iterator(self)

    def __setitem__(self, *args) -> "void":
        return _limb_py.Str2LimbMap___setitem__(self, *args)

    def asdict(self) -> "PyObject *":
        return _limb_py.Str2LimbMap_asdict(self)

    def __init__(self, *args):
        _limb_py.Str2LimbMap_swiginit(self, _limb_py.new_Str2LimbMap(*args))

    def empty(self) -> "bool":
        return _limb_py.Str2LimbMap_empty(self)

    def size(self) -> "std::map< std::string,std::shared_ptr< Limb > >::size_type":
        return _limb_py.Str2LimbMap_size(self)

    def swap(self, v: "Str2LimbMap") -> "void":
        return _limb_py.Str2LimbMap_swap(self, v)

    def begin(self) -> "std::map< std::string,std::shared_ptr< Limb > >::iterator":
        return _limb_py.Str2LimbMap_begin(self)

    def end(self) -> "std::map< std::string,std::shared_ptr< Limb > >::iterator":
        return _limb_py.Str2LimbMap_end(self)

    def rbegin(self) -> "std::map< std::string,std::shared_ptr< Limb > >::reverse_iterator":
        return _limb_py.Str2LimbMap_rbegin(self)

    def rend(self) -> "std::map< std::string,std::shared_ptr< Limb > >::reverse_iterator":
        return _limb_py.Str2LimbMap_rend(self)

    def clear(self) -> "void":
        return _limb_py.Str2LimbMap_clear(self)

    def get_allocator(self) -> "std::map< std::string,std::shared_ptr< Limb > >::allocator_type":
        return _limb_py.Str2LimbMap_get_allocator(self)

    def count(self, x: "std::map< std::string,std::shared_ptr< Limb > >::key_type const &") -> "std::map< std::string,std::shared_ptr< Limb > >::size_type":
        return _limb_py.Str2LimbMap_count(self, x)

    def erase(self, *args) -> "void":
        return _limb_py.Str2LimbMap_erase(self, *args)

    def find(self, x: "std::map< std::string,std::shared_ptr< Limb > >::key_type const &") -> "std::map< std::string,std::shared_ptr< Limb > >::iterator":
        return _limb_py.Str2LimbMap_find(self, x)

    def lower_bound(self, x: "std::map< std::string,std::shared_ptr< Limb > >::key_type const &") -> "std::map< std::string,std::shared_ptr< Limb > >::iterator":
        return _limb_py.Str2LimbMap_lower_bound(self, x)

    def upper_bound(self, x: "std::map< std::string,std::shared_ptr< Limb > >::key_type const &") -> "std::map< std::string,std::shared_ptr< Limb > >::iterator":
        return _limb_py.Str2LimbMap_upper_bound(self, x)
    __swig_destroy__ = _limb_py.delete_Str2LimbMap

# Register Str2LimbMap in _limb_py:
_limb_py.Str2LimbMap_swigregister(Str2LimbMap)

class PolynomialSolver(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _limb_py.PolynomialSolver_swiginit(self, _limb_py.new_PolynomialSolver(*args))

    def Run(self, times: "DoubleVector", node_equality_bounds: "std::vector< NodeEqualityBound,std::allocator< NodeEqualityBound > > const &", node_inequality_bounds: "std::vector< NodeInequalityBound,std::allocator< NodeInequalityBound > > const &", segment_inequality_bounds: "std::vector< SegmentInequalityBound,std::allocator< SegmentInequalityBound > > const &") -> "p4::PolynomialSolver::Solution":
        return _limb_py.PolynomialSolver_Run(self, times, node_equality_bounds, node_inequality_bounds, segment_inequality_bounds)
    __swig_destroy__ = _limb_py.delete_PolynomialSolver

# Register PolynomialSolver in _limb_py:
_limb_py.PolynomialSolver_swigregister(PolynomialSolver)

class PolynomialSampler(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _limb_py.PolynomialSampler_swiginit(self, _limb_py.new_PolynomialSampler(*args))

    def Run(self, *args) -> "Eigen::VectorXd":
        return _limb_py.PolynomialSampler_Run(self, *args)
    __swig_destroy__ = _limb_py.delete_PolynomialSampler

# Register PolynomialSampler in _limb_py:
_limb_py.PolynomialSampler_swigregister(PolynomialSampler)

RADIAN2DEGREE = _limb_py.RADIAN2DEGREE
PIE = _limb_py.PIE
EPSILON = _limb_py.EPSILON
DEGREE2RADIAN = _limb_py.DEGREE2RADIAN
XYZSEQUENCE = _limb_py.XYZSEQUENCE
LIMB_ARM_TYPE_NONE = _limb_py.LIMB_ARM_TYPE_NONE
LIMB_ARM_TYPE_KUKA_IIWA14 = _limb_py.LIMB_ARM_TYPE_KUKA_IIWA14
LIMB_ARM_TYPE_KINOVA_GEN3 = _limb_py.LIMB_ARM_TYPE_KINOVA_GEN3
LIMB_ARM_TYPE_UR3 = _limb_py.LIMB_ARM_TYPE_UR3
LIMB_ARM_TYPE_UR5 = _limb_py.LIMB_ARM_TYPE_UR5
LIMB_ARM_TYPE_UR10 = _limb_py.LIMB_ARM_TYPE_UR10
LIMB_ARM_TYPE_UR16E = _limb_py.LIMB_ARM_TYPE_UR16E
LIMB_ARM_TYPE_IRB1100 = _limb_py.LIMB_ARM_TYPE_IRB1100
class BasicParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    limb_name = property(_limb_py.BasicParameter_limb_name_get, _limb_py.BasicParameter_limb_name_set)
    limb_arm_type = property(_limb_py.BasicParameter_limb_arm_type_get, _limb_py.BasicParameter_limb_arm_type_set)
    type = property(_limb_py.BasicParameter_type_get, _limb_py.BasicParameter_type_set)
    location = property(_limb_py.BasicParameter_location_get, _limb_py.BasicParameter_location_set)
    debug = property(_limb_py.BasicParameter_debug_get, _limb_py.BasicParameter_debug_set)
    dof = property(_limb_py.BasicParameter_dof_get, _limb_py.BasicParameter_dof_set)
    frequency = property(_limb_py.BasicParameter_frequency_get, _limb_py.BasicParameter_frequency_set)
    dt = property(_limb_py.BasicParameter_dt_get, _limb_py.BasicParameter_dt_set)
    limit_velocity_scale = property(_limb_py.BasicParameter_limit_velocity_scale_get, _limb_py.BasicParameter_limit_velocity_scale_set)
    limit_acceleration_scale = property(_limb_py.BasicParameter_limit_acceleration_scale_get, _limb_py.BasicParameter_limit_acceleration_scale_set)
    limit_torque_scale = property(_limb_py.BasicParameter_limit_torque_scale_get, _limb_py.BasicParameter_limit_torque_scale_set)

    def __init__(self):
        _limb_py.BasicParameter_swiginit(self, _limb_py.new_BasicParameter())
    __swig_destroy__ = _limb_py.delete_BasicParameter

# Register BasicParameter in _limb_py:
_limb_py.BasicParameter_swigregister(BasicParameter)

class JointParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    joint_name = property(_limb_py.JointParameter_joint_name_get, _limb_py.JointParameter_joint_name_set)
    lower_position = property(_limb_py.JointParameter_lower_position_get, _limb_py.JointParameter_lower_position_set)
    upper_position = property(_limb_py.JointParameter_upper_position_get, _limb_py.JointParameter_upper_position_set)
    home_position = property(_limb_py.JointParameter_home_position_get, _limb_py.JointParameter_home_position_set)
    limit_velocity = property(_limb_py.JointParameter_limit_velocity_get, _limb_py.JointParameter_limit_velocity_set)
    limit_acceleration = property(_limb_py.JointParameter_limit_acceleration_get, _limb_py.JointParameter_limit_acceleration_set)
    limit_torque = property(_limb_py.JointParameter_limit_torque_get, _limb_py.JointParameter_limit_torque_set)
    joint_direction = property(_limb_py.JointParameter_joint_direction_get, _limb_py.JointParameter_joint_direction_set)
    joint_offset = property(_limb_py.JointParameter_joint_offset_get, _limb_py.JointParameter_joint_offset_set)
    joint_mimic = property(_limb_py.JointParameter_joint_mimic_get, _limb_py.JointParameter_joint_mimic_set)

    def __init__(self):
        _limb_py.JointParameter_swiginit(self, _limb_py.new_JointParameter())
    __swig_destroy__ = _limb_py.delete_JointParameter

# Register JointParameter in _limb_py:
_limb_py.JointParameter_swigregister(JointParameter)

class JointState(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    joint_name = property(_limb_py.JointState_joint_name_get, _limb_py.JointState_joint_name_set)
    current_position = property(_limb_py.JointState_current_position_get, _limb_py.JointState_current_position_set)
    current_velocity = property(_limb_py.JointState_current_velocity_get, _limb_py.JointState_current_velocity_set)
    current_acceleration = property(_limb_py.JointState_current_acceleration_get, _limb_py.JointState_current_acceleration_set)
    current_torque = property(_limb_py.JointState_current_torque_get, _limb_py.JointState_current_torque_set)
    current_current_torque = property(_limb_py.JointState_current_current_torque_get, _limb_py.JointState_current_current_torque_set)
    current_filter_position = property(_limb_py.JointState_current_filter_position_get, _limb_py.JointState_current_filter_position_set)
    current_filter_velocity = property(_limb_py.JointState_current_filter_velocity_get, _limb_py.JointState_current_filter_velocity_set)
    current_filter_acceleration = property(_limb_py.JointState_current_filter_acceleration_get, _limb_py.JointState_current_filter_acceleration_set)
    command_position = property(_limb_py.JointState_command_position_get, _limb_py.JointState_command_position_set)
    command_velocity = property(_limb_py.JointState_command_velocity_get, _limb_py.JointState_command_velocity_set)
    command_acceleration = property(_limb_py.JointState_command_acceleration_get, _limb_py.JointState_command_acceleration_set)
    command_torque = property(_limb_py.JointState_command_torque_get, _limb_py.JointState_command_torque_set)
    command_current_torque = property(_limb_py.JointState_command_current_torque_get, _limb_py.JointState_command_current_torque_set)
    cal_dynamics_torque = property(_limb_py.JointState_cal_dynamics_torque_get, _limb_py.JointState_cal_dynamics_torque_set)
    cal_gravity_torque = property(_limb_py.JointState_cal_gravity_torque_get, _limb_py.JointState_cal_gravity_torque_set)
    smooth_torque_para = property(_limb_py.JointState_smooth_torque_para_get, _limb_py.JointState_smooth_torque_para_set)
    smooth_velocity_para = property(_limb_py.JointState_smooth_velocity_para_get, _limb_py.JointState_smooth_velocity_para_set)
    traj_control = property(_limb_py.JointState_traj_control_get, _limb_py.JointState_traj_control_set)

    def __init__(self):
        _limb_py.JointState_swiginit(self, _limb_py.new_JointState())
    __swig_destroy__ = _limb_py.delete_JointState

# Register JointState in _limb_py:
_limb_py.JointState_swigregister(JointState)

class EndpointState(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    pose = property(_limb_py.EndpointState_pose_get, _limb_py.EndpointState_pose_set)
    twist = property(_limb_py.EndpointState_twist_get, _limb_py.EndpointState_twist_set)
    wrench = property(_limb_py.EndpointState_wrench_get, _limb_py.EndpointState_wrench_set)
    command_pose = property(_limb_py.EndpointState_command_pose_get, _limb_py.EndpointState_command_pose_set)
    command_twist = property(_limb_py.EndpointState_command_twist_get, _limb_py.EndpointState_command_twist_set)
    command_wrench = property(_limb_py.EndpointState_command_wrench_get, _limb_py.EndpointState_command_wrench_set)
    wrench_filter_parameter = property(_limb_py.EndpointState_wrench_filter_parameter_get, _limb_py.EndpointState_wrench_filter_parameter_set)
    endpoint_rpy_pose = property(_limb_py.EndpointState_endpoint_rpy_pose_get, _limb_py.EndpointState_endpoint_rpy_pose_set)
    endpoint_quaternion_pose = property(_limb_py.EndpointState_endpoint_quaternion_pose_get, _limb_py.EndpointState_endpoint_quaternion_pose_set)
    endpoint_twist = property(_limb_py.EndpointState_endpoint_twist_get, _limb_py.EndpointState_endpoint_twist_set)
    endpoint_wrench = property(_limb_py.EndpointState_endpoint_wrench_get, _limb_py.EndpointState_endpoint_wrench_set)
    endpoint_command_rpy_pose = property(_limb_py.EndpointState_endpoint_command_rpy_pose_get, _limb_py.EndpointState_endpoint_command_rpy_pose_set)
    endpoint_command_quaternion_pose = property(_limb_py.EndpointState_endpoint_command_quaternion_pose_get, _limb_py.EndpointState_endpoint_command_quaternion_pose_set)
    endpoint_command_twist = property(_limb_py.EndpointState_endpoint_command_twist_get, _limb_py.EndpointState_endpoint_command_twist_set)
    endpoint_command_wrench = property(_limb_py.EndpointState_endpoint_command_wrench_get, _limb_py.EndpointState_endpoint_command_wrench_set)
    ft_sensor = property(_limb_py.EndpointState_ft_sensor_get, _limb_py.EndpointState_ft_sensor_set)
    endpoint_ft_wrench_tool = property(_limb_py.EndpointState_endpoint_ft_wrench_tool_get, _limb_py.EndpointState_endpoint_ft_wrench_tool_set)
    endpoint_ft_wrench_world = property(_limb_py.EndpointState_endpoint_ft_wrench_world_get, _limb_py.EndpointState_endpoint_ft_wrench_world_set)
    frist_ft_sensor_msg_flag = property(_limb_py.EndpointState_frist_ft_sensor_msg_flag_get, _limb_py.EndpointState_frist_ft_sensor_msg_flag_set)
    ft_sensor_subscriber = property(_limb_py.EndpointState_ft_sensor_subscriber_get, _limb_py.EndpointState_ft_sensor_subscriber_set)
    tool_2_ft_sensor = property(_limb_py.EndpointState_tool_2_ft_sensor_get, _limb_py.EndpointState_tool_2_ft_sensor_set)
    gravity = property(_limb_py.EndpointState_gravity_get, _limb_py.EndpointState_gravity_set)
    mass_center = property(_limb_py.EndpointState_mass_center_get, _limb_py.EndpointState_mass_center_set)
    ft_bias = property(_limb_py.EndpointState_ft_bias_get, _limb_py.EndpointState_ft_bias_set)
    ros_msg_sequence = property(_limb_py.EndpointState_ros_msg_sequence_get, _limb_py.EndpointState_ros_msg_sequence_set)

    def __init__(self):
        _limb_py.EndpointState_swiginit(self, _limb_py.new_EndpointState())
    __swig_destroy__ = _limb_py.delete_EndpointState

# Register EndpointState in _limb_py:
_limb_py.EndpointState_swigregister(EndpointState)

class FTSensor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    ft_sensor = property(_limb_py.FTSensor_ft_sensor_get, _limb_py.FTSensor_ft_sensor_set)
    endpoint_ft_wrench_tool = property(_limb_py.FTSensor_endpoint_ft_wrench_tool_get, _limb_py.FTSensor_endpoint_ft_wrench_tool_set)
    endpoint_ft_wrench_world = property(_limb_py.FTSensor_endpoint_ft_wrench_world_get, _limb_py.FTSensor_endpoint_ft_wrench_world_set)
    frist_ft_sensor_msg_flag = property(_limb_py.FTSensor_frist_ft_sensor_msg_flag_get, _limb_py.FTSensor_frist_ft_sensor_msg_flag_set)

    def __init__(self):
        _limb_py.FTSensor_swiginit(self, _limb_py.new_FTSensor())
    __swig_destroy__ = _limb_py.delete_FTSensor

# Register FTSensor in _limb_py:
_limb_py.FTSensor_swigregister(FTSensor)

class DHParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    joint_name = property(_limb_py.DHParameter_joint_name_get, _limb_py.DHParameter_joint_name_set)
    dh_offset = property(_limb_py.DHParameter_dh_offset_get, _limb_py.DHParameter_dh_offset_set)
    dh_theta = property(_limb_py.DHParameter_dh_theta_get, _limb_py.DHParameter_dh_theta_set)
    dh_d = property(_limb_py.DHParameter_dh_d_get, _limb_py.DHParameter_dh_d_set)
    dh_a = property(_limb_py.DHParameter_dh_a_get, _limb_py.DHParameter_dh_a_set)
    dh_alpha = property(_limb_py.DHParameter_dh_alpha_get, _limb_py.DHParameter_dh_alpha_set)
    dh_l = property(_limb_py.DHParameter_dh_l_get, _limb_py.DHParameter_dh_l_set)

    def __init__(self):
        _limb_py.DHParameter_swiginit(self, _limb_py.new_DHParameter())
    __swig_destroy__ = _limb_py.delete_DHParameter

# Register DHParameter in _limb_py:
_limb_py.DHParameter_swigregister(DHParameter)

class KinematicsParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _dh = property(_limb_py.KinematicsParameter__dh_get, _limb_py.KinematicsParameter__dh_set)
    urdf_path = property(_limb_py.KinematicsParameter_urdf_path_get, _limb_py.KinematicsParameter_urdf_path_set)
    kdl_tree = property(_limb_py.KinematicsParameter_kdl_tree_get, _limb_py.KinematicsParameter_kdl_tree_set)
    gravity_vec = property(_limb_py.KinematicsParameter_gravity_vec_get, _limb_py.KinematicsParameter_gravity_vec_set)
    m_tracik_solver = property(_limb_py.KinematicsParameter_m_tracik_solver_get, _limb_py.KinematicsParameter_m_tracik_solver_set)
    m_fk_solver = property(_limb_py.KinematicsParameter_m_fk_solver_get, _limb_py.KinematicsParameter_m_fk_solver_set)
    m_jnt_to_jac_solver = property(_limb_py.KinematicsParameter_m_jnt_to_jac_solver_get, _limb_py.KinematicsParameter_m_jnt_to_jac_solver_set)
    m_dyn_param = property(_limb_py.KinematicsParameter_m_dyn_param_get, _limb_py.KinematicsParameter_m_dyn_param_set)
    m_chain = property(_limb_py.KinematicsParameter_m_chain_get, _limb_py.KinematicsParameter_m_chain_set)
    m_gra_chain = property(_limb_py.KinematicsParameter_m_gra_chain_get, _limb_py.KinematicsParameter_m_gra_chain_set)
    m_chain_start = property(_limb_py.KinematicsParameter_m_chain_start_get, _limb_py.KinematicsParameter_m_chain_start_set)
    m_chain_end = property(_limb_py.KinematicsParameter_m_chain_end_get, _limb_py.KinematicsParameter_m_chain_end_set)
    m_gravity_chain_end = property(_limb_py.KinematicsParameter_m_gravity_chain_end_get, _limb_py.KinematicsParameter_m_gravity_chain_end_set)
    collision_detection_flag = property(_limb_py.KinematicsParameter_collision_detection_flag_get, _limb_py.KinematicsParameter_collision_detection_flag_set)
    min_collision_distance = property(_limb_py.KinematicsParameter_min_collision_distance_get, _limb_py.KinematicsParameter_min_collision_distance_set)
    nearest_points = property(_limb_py.KinematicsParameter_nearest_points_get, _limb_py.KinematicsParameter_nearest_points_set)
    Ttorso2base = property(_limb_py.KinematicsParameter_Ttorso2base_get, _limb_py.KinematicsParameter_Ttorso2base_set)
    Ttool2effector = property(_limb_py.KinematicsParameter_Ttool2effector_get, _limb_py.KinematicsParameter_Ttool2effector_set)

    def __init__(self):
        _limb_py.KinematicsParameter_swiginit(self, _limb_py.new_KinematicsParameter())
    __swig_destroy__ = _limb_py.delete_KinematicsParameter

# Register KinematicsParameter in _limb_py:
_limb_py.KinematicsParameter_swigregister(KinematicsParameter)

class DynamicsParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    max_load_scale = property(_limb_py.DynamicsParameter_max_load_scale_get, _limb_py.DynamicsParameter_max_load_scale_set)

    def __init__(self):
        _limb_py.DynamicsParameter_swiginit(self, _limb_py.new_DynamicsParameter())
    __swig_destroy__ = _limb_py.delete_DynamicsParameter

# Register DynamicsParameter in _limb_py:
_limb_py.DynamicsParameter_swigregister(DynamicsParameter)

class EffectorParameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    mode = property(_limb_py.EffectorParameter_mode_get, _limb_py.EffectorParameter_mode_set)
    scale = property(_limb_py.EffectorParameter_scale_get, _limb_py.EffectorParameter_scale_set)

    def __init__(self):
        _limb_py.EffectorParameter_swiginit(self, _limb_py.new_EffectorParameter())
    __swig_destroy__ = _limb_py.delete_EffectorParameter

# Register EffectorParameter in _limb_py:
_limb_py.EffectorParameter_swigregister(EffectorParameter)

class JoyDebugKey(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    time_forward = property(_limb_py.JoyDebugKey_time_forward_get, _limb_py.JoyDebugKey_time_forward_set)
    time_backward = property(_limb_py.JoyDebugKey_time_backward_get, _limb_py.JoyDebugKey_time_backward_set)
    velocity_forward = property(_limb_py.JoyDebugKey_velocity_forward_get, _limb_py.JoyDebugKey_velocity_forward_set)
    velocity_backward = property(_limb_py.JoyDebugKey_velocity_backward_get, _limb_py.JoyDebugKey_velocity_backward_set)

    def __init__(self):
        _limb_py.JoyDebugKey_swiginit(self, _limb_py.new_JoyDebugKey())
    __swig_destroy__ = _limb_py.delete_JoyDebugKey

# Register JoyDebugKey in _limb_py:
_limb_py.JoyDebugKey_swigregister(JoyDebugKey)

class Config(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    config_file_path = property(_limb_py.Config_config_file_path_get, _limb_py.Config_config_file_path_set)
    _BasicParameter = property(_limb_py.Config__BasicParameter_get, _limb_py.Config__BasicParameter_set)
    _JointParameter = property(_limb_py.Config__JointParameter_get, _limb_py.Config__JointParameter_set)
    _JointState = property(_limb_py.Config__JointState_get, _limb_py.Config__JointState_set)
    _EndpointState = property(_limb_py.Config__EndpointState_get, _limb_py.Config__EndpointState_set)
    _KinematicsParameter = property(_limb_py.Config__KinematicsParameter_get, _limb_py.Config__KinematicsParameter_set)
    _DynamicsParameter = property(_limb_py.Config__DynamicsParameter_get, _limb_py.Config__DynamicsParameter_set)
    _EffectorParameter = property(_limb_py.Config__EffectorParameter_get, _limb_py.Config__EffectorParameter_set)
    n = property(_limb_py.Config_n_get, _limb_py.Config_n_set)
    debug = property(_limb_py.Config_debug_get, _limb_py.Config_debug_set)
    time_start = property(_limb_py.Config_time_start_get, _limb_py.Config_time_start_set)
    time_now = property(_limb_py.Config_time_now_get, _limb_py.Config_time_now_set)
    visual_tools_ = property(_limb_py.Config_visual_tools__get, _limb_py.Config_visual_tools__set)

    def __init__(self, *args):
        _limb_py.Config_swiginit(self, _limb_py.new_Config(*args))

    def configInit(self, filePathName: "std::string const &") -> "void":
        return _limb_py.Config_configInit(self, filePathName)
    __swig_destroy__ = _limb_py.delete_Config

    def getFilePath(self) -> "std::string":
        return _limb_py.Config_getFilePath(self)

    def getDoF(self) -> "int":
        return _limb_py.Config_getDoF(self)

    def getLimbName(self) -> "std::string":
        return _limb_py.Config_getLimbName(self)

    def getLimbArmType(self) -> "LimbArmType":
        return _limb_py.Config_getLimbArmType(self)

    def GetType(self) -> "manipulator::component::Type":
        return _limb_py.Config_GetType(self)

    def GetLocation(self) -> "manipulator::component::Location":
        return _limb_py.Config_GetLocation(self)

    def getNodeName(self) -> "std::string":
        return _limb_py.Config_getNodeName(self)

    def getControlFrequency(self) -> "int":
        return _limb_py.Config_getControlFrequency(self)

    def getDt(self) -> "double":
        return _limb_py.Config_getDt(self)

    def getLimitVelocityScale(self) -> "double":
        return _limb_py.Config_getLimitVelocityScale(self)

    def getLimitAccelerationScale(self) -> "double":
        return _limb_py.Config_getLimitAccelerationScale(self)

    def getLimitTorqueScale(self) -> "double":
        return _limb_py.Config_getLimitTorqueScale(self)

    def getJointName(self) -> "std::vector< std::string,std::allocator< std::string > >":
        return _limb_py.Config_getJointName(self)

    def getJointLowerPosition(self) -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Config_getJointLowerPosition(self)

    def getJointUpperPosition(self) -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Config_getJointUpperPosition(self)

    def getJointHomePosition(self) -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Config_getJointHomePosition(self)

    def getJointLimitVelocity(self) -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Config_getJointLimitVelocity(self)

    def getJointLimitAcceleration(self) -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Config_getJointLimitAcceleration(self)

    def getJointLimitTorque(self) -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Config_getJointLimitTorque(self)

    def getJointDirection(self) -> "std::vector< int,std::allocator< int > >":
        return _limb_py.Config_getJointDirection(self)

    def getJointOffset(self) -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Config_getJointOffset(self)

    def getJointMimic(self) -> "std::vector< int,std::allocator< int > >":
        return _limb_py.Config_getJointMimic(self)

    def limitMimicJoint(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Config_limitMimicJoint(self, *args)

    def getDhA(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getDhA(self)

    def getDhD(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getDhD(self)

    def getDhAlpha(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getDhAlpha(self)

    def getDhTheta(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getDhTheta(self)

    def getCurrentJointPosition(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCurrentJointPosition(self)

    def getCurrentJointVelocity(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCurrentJointVelocity(self)

    def getCurrentJointTorque(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCurrentJointTorque(self)

    def getCurrentJointCurrentTorque(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCurrentJointCurrentTorque(self)

    def getCurrentJointAcceleration(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCurrentJointAcceleration(self)

    def getCurrentJointFilterPosition(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCurrentJointFilterPosition(self)

    def getCurrentJointFilterVelocity(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCurrentJointFilterVelocity(self)

    def getCurrentJointFilterAcceleration(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCurrentJointFilterAcceleration(self)

    def getCommandJointPosition(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCommandJointPosition(self)

    def getCommandJointVelocity(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCommandJointVelocity(self)

    def getCommandJointAcceleration(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCommandJointAcceleration(self)

    def getCommandJointTorque(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCommandJointTorque(self)

    def getCommandJointCurrentTorque(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCommandJointCurrentTorque(self)

    def getEndpointRPYPose(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointRPYPose(self)

    def getEndpointQuaternionPose(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointQuaternionPose(self)

    def getEndpointTwist(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointTwist(self)

    def getEndpointWrench(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointWrench(self)

    def getEndpointCurrentRPYPose(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointCurrentRPYPose(self)

    def getEndpointCurrentQuaternionPose(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointCurrentQuaternionPose(self)

    def getEndpointCurrentTwist(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointCurrentTwist(self)

    def getEndpointCurrentWrench(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointCurrentWrench(self)

    def getEndpointCommandRPYPose(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointCommandRPYPose(self)

    def getEndpointCommandQuaternionPose(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointCommandQuaternionPose(self)

    def getEndpointCommandTwist(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointCommandTwist(self)

    def getEndpointCommandWrench(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointCommandWrench(self)

    def getEndpointFTWrenchTool(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointFTWrenchTool(self)

    def getEndpointFTWrenchWorld(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getEndpointFTWrenchWorld(self)

    def GetEndpointFTRosMsgSequence(self) -> "uint32_t":
        return _limb_py.Config_GetEndpointFTRosMsgSequence(self)

    def getCalDynamicsTorque(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCalDynamicsTorque(self)

    def getCalGravityTorque(self) -> "Eigen::VectorXd":
        return _limb_py.Config_getCalGravityTorque(self)

    def GetTorso2BaseTransformation(self) -> "Eigen::Matrix4d":
        return _limb_py.Config_GetTorso2BaseTransformation(self)

    def GetTool2EffectorTransformation(self) -> "Eigen::Matrix4d":
        return _limb_py.Config_GetTool2EffectorTransformation(self)

    def getEffectorMode(self) -> "std::string":
        return _limb_py.Config_getEffectorMode(self)

    def getEffectorScale(self) -> "double":
        return _limb_py.Config_getEffectorScale(self)

    def getMinCollisionDistance(self) -> "double":
        return _limb_py.Config_getMinCollisionDistance(self)

    def getMinCollisionPoint(self) -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _limb_py.Config_getMinCollisionPoint(self)

    def setCurrentJointPosition(self, pos: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCurrentJointPosition(self, pos)

    def setCurrentJointVelocity(self, vel: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCurrentJointVelocity(self, vel)

    def setCurrentJointTorque(self, tor: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCurrentJointTorque(self, tor)

    def setCurrentJointCurrentTorque(self, tor: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCurrentJointCurrentTorque(self, tor)

    def setCurrentJointAcceleration(self, acc: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCurrentJointAcceleration(self, acc)

    def setCurrentJointFilterPosition(self, pos: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCurrentJointFilterPosition(self, pos)

    def setCurrentJointFilterVelocity(self, vel: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCurrentJointFilterVelocity(self, vel)

    def setCurrentJointFilterAcceleration(self, acc: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCurrentJointFilterAcceleration(self, acc)

    def setCommandJointPosition(self, pos: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCommandJointPosition(self, pos)

    def setCommandJointVelocity(self, vel: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCommandJointVelocity(self, vel)

    def setCommandJointTorque(self, tor: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCommandJointTorque(self, tor)

    def setCommandJointCurrentTorque(self, tor: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCommandJointCurrentTorque(self, tor)

    def setCommandJointAcceleration(self, acc: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCommandJointAcceleration(self, acc)

    def setEndpointRPYPose(self, x: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointRPYPose(self, x)

    def setEndpointQuaternionPose(self, pose: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointQuaternionPose(self, pose)

    def setEndpointTwist(self, twist: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointTwist(self, twist)

    def setEndpointWrench(self, wrench: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointWrench(self, wrench)

    def setEndpointCommandRPYPose(self, x: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointCommandRPYPose(self, x)

    def setEndpointCommandQuaternionPose(self, pose: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointCommandQuaternionPose(self, pose)

    def setEndpointCommandTwist(self, twist: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointCommandTwist(self, twist)

    def setEndpointCommandWrench(self, wrench: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointCommandWrench(self, wrench)

    def setEndpointFTWrenchTool(self, wrench: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointFTWrenchTool(self, wrench)

    def SetEndpointFTRosMsgSequence(self, seq: "uint32_t") -> "void":
        return _limb_py.Config_SetEndpointFTRosMsgSequence(self, seq)

    def setEndpointFTWrenchWorld(self, wrench: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setEndpointFTWrenchWorld(self, wrench)

    def setCalDynamicsTorque(self, torque: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCalDynamicsTorque(self, torque)

    def setCalGravityTorque(self, torque: "Eigen::VectorXd") -> "void":
        return _limb_py.Config_setCalGravityTorque(self, torque)

    def setMinCollisionDistance(self, distance: "double") -> "void":
        return _limb_py.Config_setMinCollisionDistance(self, distance)

    def setMinCollisionPoint(self, nearest_points: "vector_vector_double") -> "void":
        return _limb_py.Config_setMinCollisionPoint(self, nearest_points)

    def setEffectorMode(self, mode: "std::string") -> "void":
        return _limb_py.Config_setEffectorMode(self, mode)

    def setEffectorScale(self, scale: "double") -> "void":
        return _limb_py.Config_setEffectorScale(self, scale)

    def setLimitVelocityScale(self, scale: "double") -> "void":
        return _limb_py.Config_setLimitVelocityScale(self, scale)

    def setLimitAccelerationScale(self, scale: "double") -> "void":
        return _limb_py.Config_setLimitAccelerationScale(self, scale)

    def setLimitTorqueScale(self, scale: "double") -> "void":
        return _limb_py.Config_setLimitTorqueScale(self, scale)

    def transEigenVector2Jnt(self, data_in: "Eigen::VectorXd") -> "KDL::JntArray":
        return _limb_py.Config_transEigenVector2Jnt(self, data_in)

    def transJnt2EigenVector(self, data_in_v: "KDL::JntArray") -> "Eigen::VectorXd":
        return _limb_py.Config_transJnt2EigenVector(self, data_in_v)

    def transKdlJacobian2Eigen(self, jac: "KDL::Jacobian const &", jacobian: "Eigen::MatrixXd *") -> "void":
        return _limb_py.Config_transKdlJacobian2Eigen(self, jac, jacobian)

    def transStd2Eigen(self, data_in_v: "DoubleVector") -> "Eigen::VectorXd":
        return _limb_py.Config_transStd2Eigen(self, data_in_v)

    def transStd2DoubleArray(self, data_in_v: "DoubleVector", data: "double *") -> "void":
        return _limb_py.Config_transStd2DoubleArray(self, data_in_v, data)

    @staticmethod
    def transEigen2Std(data_in: "Eigen::VectorXd") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Config_transEigen2Std(data_in)

    def transEigenVector2Double(self, data_in: "Eigen::VectorXd") -> "double *":
        return _limb_py.Config_transEigenVector2Double(self, data_in)

    def transDouble2EigenVector(self, data_in: "double *") -> "Eigen::VectorXd":
        return _limb_py.Config_transDouble2EigenVector(self, data_in)

    @staticmethod
    def transEigenMatrix2Double(data_in: "Eigen::MatrixXd") -> "double *":
        return _limb_py.Config_transEigenMatrix2Double(data_in)

    @staticmethod
    def transDouble2EigenMatrix(data_in: "double *", rows: "uint", cols: "uint") -> "Eigen::MatrixXd":
        return _limb_py.Config_transDouble2EigenMatrix(data_in, rows, cols)

    def limitPosition(self, pos: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.Config_limitPosition(self, pos)

    def limitVelocity(self, vel: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.Config_limitVelocity(self, vel)

    def limitAcceleration(self, acc: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.Config_limitAcceleration(self, acc)

    def limitTorque(self, tor: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.Config_limitTorque(self, tor)

    def getTickUs(self) -> "int64_t":
        return _limb_py.Config_getTickUs(self)

    def timeInit(self) -> "void":
        return _limb_py.Config_timeInit(self)

    def getTime(self) -> "double":
        return _limb_py.Config_getTime(self)

    def dealDeadArea(self, original_value: "DoubleVector", up_dead_area: "DoubleVector", low_dead_area: "DoubleVector"=None) -> "void":
        return _limb_py.Config_dealDeadArea(self, original_value, up_dead_area, low_dead_area)

    def debugData(self, *args) -> "void":
        return _limb_py.Config_debugData(self, *args)

    def rvizVisualToolInit(self, base_frame: "std::string") -> "void":
        return _limb_py.Config_rvizVisualToolInit(self, base_frame)

    def publishRvizSphere(self, pos: "Eigen::Vector3d", color: "rviz_visual_tools::colors") -> "void":
        return _limb_py.Config_publishRvizSphere(self, pos, color)

    def InitSensorConfig(self, config: "YAML::Node const &") -> "void":
        return _limb_py.Config_InitSensorConfig(self, config)

    def GetTactileSensorConfig(self) -> "YAML::Node":
        return _limb_py.Config_GetTactileSensorConfig(self)

    def RequestStop(self) -> "void":
        return _limb_py.Config_RequestStop(self)

    def IsStopRequested(self) -> "bool":
        return _limb_py.Config_IsStopRequested(self)

# Register Config in _limb_py:
_limb_py.Config_swigregister(Config)

def Config_transEigen2Std(data_in: "Eigen::VectorXd") -> "std::vector< double,std::allocator< double > >":
    return _limb_py.Config_transEigen2Std(data_in)

def Config_transEigenMatrix2Double(data_in: "Eigen::MatrixXd") -> "double *":
    return _limb_py.Config_transEigenMatrix2Double(data_in)

def Config_transDouble2EigenMatrix(data_in: "double *", rows: "uint", cols: "uint") -> "Eigen::MatrixXd":
    return _limb_py.Config_transDouble2EigenMatrix(data_in, rows, cols)

class VisualObjectPoseImpl(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, params: "YAML::Node const &"):
        _limb_py.VisualObjectPoseImpl_swiginit(self, _limb_py.new_VisualObjectPoseImpl(params))
    __swig_destroy__ = _limb_py.delete_VisualObjectPoseImpl

    def UpdateVisualObjectInfoAtEndpoint(self, description: "std::string const &", input: "VisualObjectPoseImpl::EstimatorInput const &") -> "void":
        return _limb_py.VisualObjectPoseImpl_UpdateVisualObjectInfoAtEndpoint(self, description, input)

    def GetPoseFromPerception(self, input: "VisualObjectPoseImpl::EstimatorInput const &", pose2base: "Eigen::VectorXd &") -> "bool":
        return _limb_py.VisualObjectPoseImpl_GetPoseFromPerception(self, input, pose2base)

    def GetPoseFromVicon(self, id: "std::string const &", pose2torso: "Eigen::VectorXd &", time: "double *"=None) -> "bool":
        return _limb_py.VisualObjectPoseImpl_GetPoseFromVicon(self, id, pose2torso, time)

    def EnableRecordTrajectoryFromVicon(self, enable: "bool"=False) -> "void":
        return _limb_py.VisualObjectPoseImpl_EnableRecordTrajectoryFromVicon(self, enable)

    def GetTrajectoryFromVicon(self, id: "std::string const &") -> "ObjectTraj":
        return _limb_py.VisualObjectPoseImpl_GetTrajectoryFromVicon(self, id)

    def GetVicon2TorsoFrameTransformation(self) -> "std::optional< Eigen::Matrix4d >":
        return _limb_py.VisualObjectPoseImpl_GetVicon2TorsoFrameTransformation(self)

# Register VisualObjectPoseImpl in _limb_py:
_limb_py.VisualObjectPoseImpl_swigregister(VisualObjectPoseImpl)

class TrxTactileDataManager(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, topic_name: "std::string const &", type: "manipulator::component::Type"):
        _limb_py.TrxTactileDataManager_swiginit(self, _limb_py.new_TrxTactileDataManager(topic_name, type))

    def GetStateByTypeAndLocations(self, type: "manipulator::sensor::TrxTactileDataManager::TrxTactileSensorType", locations: "std::vector< manipulator::sensor::TrxTactileDataManager::TrxTactileSensorLocation,std::allocator< manipulator::sensor::TrxTactileDataManager::TrxTactileSensorLocation > > const &", zero_values_calibration: "bool"=False) -> "std::vector< int,std::allocator< int > >":
        return _limb_py.TrxTactileDataManager_GetStateByTypeAndLocations(self, type, locations, zero_values_calibration)

    def SetPressureStateZeroValues(self) -> "bool":
        return _limb_py.TrxTactileDataManager_SetPressureStateZeroValues(self)

    def GetPressureStateZeroValues(self) -> "std::vector< int,std::allocator< int > >":
        return _limb_py.TrxTactileDataManager_GetPressureStateZeroValues(self)
    __swig_destroy__ = _limb_py.delete_TrxTactileDataManager

# Register TrxTactileDataManager in _limb_py:
_limb_py.TrxTactileDataManager_swigregister(TrxTactileDataManager)

class KalmanState(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    x = property(_limb_py.KalmanState_x_get, _limb_py.KalmanState_x_set)
    A = property(_limb_py.KalmanState_A_get, _limb_py.KalmanState_A_set)
    H = property(_limb_py.KalmanState_H_get, _limb_py.KalmanState_H_set)
    q = property(_limb_py.KalmanState_q_get, _limb_py.KalmanState_q_set)
    r = property(_limb_py.KalmanState_r_get, _limb_py.KalmanState_r_set)
    p = property(_limb_py.KalmanState_p_get, _limb_py.KalmanState_p_set)
    gain = property(_limb_py.KalmanState_gain_get, _limb_py.KalmanState_gain_set)

    def __init__(self):
        _limb_py.KalmanState_swiginit(self, _limb_py.new_KalmanState())
    __swig_destroy__ = _limb_py.delete_KalmanState

# Register KalmanState in _limb_py:
_limb_py.KalmanState_swigregister(KalmanState)

class KalmanStates(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    kalman_state = property(_limb_py.KalmanStates_kalman_state_get, _limb_py.KalmanStates_kalman_state_set)

    def __init__(self):
        _limb_py.KalmanStates_swiginit(self, _limb_py.new_KalmanStates())
    __swig_destroy__ = _limb_py.delete_KalmanStates

# Register KalmanStates in _limb_py:
_limb_py.KalmanStates_swigregister(KalmanStates)

class Filter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, filter_factor: "DoubleVector"):
        _limb_py.Filter_swiginit(self, _limb_py.new_Filter(filter_factor))
    __swig_destroy__ = _limb_py.delete_Filter

    def filterData(self, cur_vec: "DoubleVector") -> "void":
        return _limb_py.Filter_filterData(self, cur_vec)

# Register Filter in _limb_py:
_limb_py.Filter_swigregister(Filter)

class Transformer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _config = property(_limb_py.Transformer__config_get, _limb_py.Transformer__config_set)
    mJointCurrentPositionKalmanFilter = property(_limb_py.Transformer_mJointCurrentPositionKalmanFilter_get, _limb_py.Transformer_mJointCurrentPositionKalmanFilter_set)
    mJointCommandPositionKalmanFilter = property(_limb_py.Transformer_mJointCommandPositionKalmanFilter_get, _limb_py.Transformer_mJointCommandPositionKalmanFilter_set)
    mJointCurrentVelocityKalmanFilter = property(_limb_py.Transformer_mJointCurrentVelocityKalmanFilter_get, _limb_py.Transformer_mJointCurrentVelocityKalmanFilter_set)
    mJointCommandVelocityKalmanFilter = property(_limb_py.Transformer_mJointCommandVelocityKalmanFilter_get, _limb_py.Transformer_mJointCommandVelocityKalmanFilter_set)

    def __init__(self, *args):
        _limb_py.Transformer_swiginit(self, _limb_py.new_Transformer(*args))

    def calKalmanFilterInit(self, *args) -> "void":
        return _limb_py.Transformer_calKalmanFilterInit(self, *args)

    def calKalmanFilter(self, *args) -> "void":
        return _limb_py.Transformer_calKalmanFilter(self, *args)

    def calJointPositionKalmanFilterInit(self, init_q: "Eigen::VectorXd", init_qv: "Eigen::VectorXd", Q: "Eigen::VectorXd", R: "Eigen::VectorXd", cmd: "bool") -> "void":
        return _limb_py.Transformer_calJointPositionKalmanFilterInit(self, init_q, init_qv, Q, R, cmd)

    def calJointVelocityKalmanFilterInit(self, init_qv: "Eigen::VectorXd", init_qa: "Eigen::VectorXd", Q: "Eigen::VectorXd", R: "Eigen::VectorXd", cmd: "bool") -> "void":
        return _limb_py.Transformer_calJointVelocityKalmanFilterInit(self, init_qv, init_qa, Q, R, cmd)

    def calJointPositionKalmanFilter(self, q: "Eigen::VectorXd", qout: "double *", qvout: "double *", cmd: "bool") -> "void":
        return _limb_py.Transformer_calJointPositionKalmanFilter(self, q, qout, qvout, cmd)

    def calJointVelocityKalmanFilter(self, qv: "Eigen::VectorXd", qvout: "double *", qaout: "double *", cmd: "bool") -> "void":
        return _limb_py.Transformer_calJointVelocityKalmanFilter(self, qv, qvout, qaout, cmd)

    def calJointKalmanFilterInit(self, init_q: "Eigen::VectorXd", init_qv: "Eigen::VectorXd", init_qa: "Eigen::VectorXd", Q: "double", R: "double", cmd: "bool") -> "void":
        return _limb_py.Transformer_calJointKalmanFilterInit(self, init_q, init_qv, init_qa, Q, R, cmd)

    def calJointKalmanFilter(self, q: "Eigen::VectorXd", frequency: "int", cmd: "bool") -> "std::vector< std::vector< double,std::allocator< double > >,std::allocator< std::vector< double,std::allocator< double > > > >":
        return _limb_py.Transformer_calJointKalmanFilter(self, q, frequency, cmd)
    __swig_destroy__ = _limb_py.delete_Transformer

# Register Transformer in _limb_py:
_limb_py.Transformer_swigregister(Transformer)

class KinematicsTrans(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def DH2TMatrix(q: "double", dh: "DHParameter") -> "Eigen::Matrix4d":
        return _limb_py.KinematicsTrans_DH2TMatrix(q, dh)

    @staticmethod
    def TMatrix(*args) -> "Eigen::Matrix4d":
        return _limb_py.KinematicsTrans_TMatrix(*args)

    @staticmethod
    def transPosition2TMatrix(*args) -> "Eigen::Matrix4d":
        return _limb_py.KinematicsTrans_transPosition2TMatrix(*args)

    @staticmethod
    def transTMatrix2RPYPose(*args) -> "Eigen::VectorXd":
        return _limb_py.KinematicsTrans_transTMatrix2RPYPose(*args)

    @staticmethod
    def transTMatrix2RPY(*args) -> "Eigen::Vector3d":
        return _limb_py.KinematicsTrans_transTMatrix2RPY(*args)

    @staticmethod
    def transTMatrix2Position(T: "Eigen::Matrix4d") -> "Eigen::Vector3d":
        return _limb_py.KinematicsTrans_transTMatrix2Position(T)

    @staticmethod
    def transQuaternion2TMatrix(quat: "Eigen::VectorXd") -> "Eigen::Matrix4d":
        return _limb_py.KinematicsTrans_transQuaternion2TMatrix(quat)

    @staticmethod
    def transTMatrix2Quaternion(T: "Eigen::MatrixXd") -> "Eigen::VectorXd":
        return _limb_py.KinematicsTrans_transTMatrix2Quaternion(T)

    @staticmethod
    def transTMatrix2Axis(T: "Eigen::MatrixXd") -> "Eigen::VectorXd":
        return _limb_py.KinematicsTrans_transTMatrix2Axis(T)

    @staticmethod
    def transRPYPose2TMatrix(rpy_pose: "Eigen::VectorXd") -> "Eigen::Matrix4d":
        return _limb_py.KinematicsTrans_transRPYPose2TMatrix(rpy_pose)

    @staticmethod
    def transTMatrix2QuaternionPose(T: "Eigen::MatrixXd") -> "Eigen::VectorXd":
        return _limb_py.KinematicsTrans_transTMatrix2QuaternionPose(T)

    @staticmethod
    def transQuaternionPose2TMatrix(pose: "Eigen::VectorXd") -> "Eigen::MatrixXd":
        return _limb_py.KinematicsTrans_transQuaternionPose2TMatrix(pose)

    @staticmethod
    def transQuaternionPose2RPYPose(pose: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.KinematicsTrans_transQuaternionPose2RPYPose(pose)

    @staticmethod
    def transQuaternionPoseInverse(pose: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.KinematicsTrans_transQuaternionPoseInverse(pose)

    @staticmethod
    def sgn(x: "double") -> "int":
        return _limb_py.KinematicsTrans_sgn(x)

    def __init__(self):
        _limb_py.KinematicsTrans_swiginit(self, _limb_py.new_KinematicsTrans())
    __swig_destroy__ = _limb_py.delete_KinematicsTrans

# Register KinematicsTrans in _limb_py:
_limb_py.KinematicsTrans_swigregister(KinematicsTrans)

def KinematicsTrans_DH2TMatrix(q: "double", dh: "DHParameter") -> "Eigen::Matrix4d":
    return _limb_py.KinematicsTrans_DH2TMatrix(q, dh)

def KinematicsTrans_TMatrix(*args) -> "Eigen::Matrix4d":
    return _limb_py.KinematicsTrans_TMatrix(*args)

def KinematicsTrans_transPosition2TMatrix(*args) -> "Eigen::Matrix4d":
    return _limb_py.KinematicsTrans_transPosition2TMatrix(*args)

def KinematicsTrans_transTMatrix2RPYPose(*args) -> "Eigen::VectorXd":
    return _limb_py.KinematicsTrans_transTMatrix2RPYPose(*args)

def KinematicsTrans_transTMatrix2RPY(*args) -> "Eigen::Vector3d":
    return _limb_py.KinematicsTrans_transTMatrix2RPY(*args)

def KinematicsTrans_transTMatrix2Position(T: "Eigen::Matrix4d") -> "Eigen::Vector3d":
    return _limb_py.KinematicsTrans_transTMatrix2Position(T)

def KinematicsTrans_transQuaternion2TMatrix(quat: "Eigen::VectorXd") -> "Eigen::Matrix4d":
    return _limb_py.KinematicsTrans_transQuaternion2TMatrix(quat)

def KinematicsTrans_transTMatrix2Quaternion(T: "Eigen::MatrixXd") -> "Eigen::VectorXd":
    return _limb_py.KinematicsTrans_transTMatrix2Quaternion(T)

def KinematicsTrans_transTMatrix2Axis(T: "Eigen::MatrixXd") -> "Eigen::VectorXd":
    return _limb_py.KinematicsTrans_transTMatrix2Axis(T)

def KinematicsTrans_transRPYPose2TMatrix(rpy_pose: "Eigen::VectorXd") -> "Eigen::Matrix4d":
    return _limb_py.KinematicsTrans_transRPYPose2TMatrix(rpy_pose)

def KinematicsTrans_transTMatrix2QuaternionPose(T: "Eigen::MatrixXd") -> "Eigen::VectorXd":
    return _limb_py.KinematicsTrans_transTMatrix2QuaternionPose(T)

def KinematicsTrans_transQuaternionPose2TMatrix(pose: "Eigen::VectorXd") -> "Eigen::MatrixXd":
    return _limb_py.KinematicsTrans_transQuaternionPose2TMatrix(pose)

def KinematicsTrans_transQuaternionPose2RPYPose(pose: "Eigen::VectorXd") -> "Eigen::VectorXd":
    return _limb_py.KinematicsTrans_transQuaternionPose2RPYPose(pose)

def KinematicsTrans_transQuaternionPoseInverse(pose: "Eigen::VectorXd") -> "Eigen::VectorXd":
    return _limb_py.KinematicsTrans_transQuaternionPoseInverse(pose)

def KinematicsTrans_sgn(x: "double") -> "int":
    return _limb_py.KinematicsTrans_sgn(x)

class Kinematics(KinematicsTrans):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _config = property(_limb_py.Kinematics__config_get, _limb_py.Kinematics__config_set)

    def __init__(self, *args):
        _limb_py.Kinematics_swiginit(self, _limb_py.new_Kinematics(*args))

    def CalcJointAnglesForEndEffectorPose(self, initial_joint_angles: "Eigen::VectorXd const &", target_X_TorsoEe: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_CalcJointAnglesForEndEffectorPose(self, initial_joint_angles, target_X_TorsoEe)

    def CalcJointAnglesForToolPose(self, initial_joint_angles: "Eigen::VectorXd const &", target_X_TorsoTool: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_CalcJointAnglesForToolPose(self, initial_joint_angles, target_X_TorsoTool)

    def CalcJointAnglesForEndEffectorPoseWithKdl(self, initial_joint_angles: "Eigen::VectorXd const &", target_X_TorsoEe: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_CalcJointAnglesForEndEffectorPoseWithKdl(self, initial_joint_angles, target_X_TorsoEe)

    def CalcJointAnglesForToolPoseWithKdl(self, initial_joint_angles: "Eigen::VectorXd const &", target_X_TorsoTool: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_CalcJointAnglesForToolPoseWithKdl(self, initial_joint_angles, target_X_TorsoTool)

    def CalcJointAnglesWithKdl(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Kinematics_CalcJointAnglesWithKdl(self, *args)

    def CalcEndEffectorPose(self, joint_angles: "Eigen::VectorXd const &") -> "Eigen::MatrixXd":
        return _limb_py.Kinematics_CalcEndEffectorPose(self, joint_angles)

    def CalcToolPose(self, joint_angles: "Eigen::VectorXd const &") -> "Eigen::MatrixXd":
        return _limb_py.Kinematics_CalcToolPose(self, joint_angles)

    def CalcEndEffectorPoseWithKdl(self, joint_angles: "Eigen::VectorXd const &") -> "Eigen::MatrixXd":
        return _limb_py.Kinematics_CalcEndEffectorPoseWithKdl(self, joint_angles)

    def CalcToolPoseWithKdl(self, joint_angles: "Eigen::VectorXd const &") -> "Eigen::MatrixXd":
        return _limb_py.Kinematics_CalcToolPoseWithKdl(self, joint_angles)

    def CalcPoseWithKdl(self, joint_angles: "Eigen::VectorXd const &", chain_start: "std::string const &", chain_end: "std::string const &") -> "Eigen::MatrixXd":
        return _limb_py.Kinematics_CalcPoseWithKdl(self, joint_angles, chain_start, chain_end)

    def calJacobianKDL(self, *args) -> "Eigen::MatrixXd":
        return _limb_py.Kinematics_calJacobianKDL(self, *args)

    def transBase2Tool(self, Tbase2tool: "Eigen::MatrixXd const &", dx_base: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_transBase2Tool(self, Tbase2tool, dx_base)

    def transTool2Base(self, Tbase2tool: "Eigen::MatrixXd const &", dx_tool: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_transTool2Base(self, Tbase2tool, dx_tool)

    def transBase2Torso(self, dx_base: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_transBase2Torso(self, dx_base)

    def transTorso2Base(self, dx_torso: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_transTorso2Base(self, dx_torso)

    def calEndpointRPYPose(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Kinematics_calEndpointRPYPose(self, *args)

    def calEndpointQuaternionPose(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Kinematics_calEndpointQuaternionPose(self, *args)

    def calEndpointTwist(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Kinematics_calEndpointTwist(self, *args)

    def calEndpointWrenchInTorso(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Kinematics_calEndpointWrenchInTorso(self, *args)

    def calRelativePoseAddTool(self, pose1: "Eigen::VectorXd const &", pose2: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_calRelativePoseAddTool(self, pose1, pose2)

    def calRelativePoseAddWorld(self, pose1: "Eigen::VectorXd const &", pose2: "Eigen::VectorXd const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_calRelativePoseAddWorld(self, pose1, pose2)

    def calCartesianSpaceOffset(self, pose: "Eigen::VectorXd const &", offset: "Eigen::VectorXd const &", coordinate_type: "std::string const &") -> "Eigen::VectorXd":
        return _limb_py.Kinematics_calCartesianSpaceOffset(self, pose, offset, coordinate_type)

    def pinv(self, mat_in: "Eigen::MatrixXd &", mat_out: "Eigen::MatrixXd &") -> "void":
        return _limb_py.Kinematics_pinv(self, mat_in, mat_out)
    __swig_destroy__ = _limb_py.delete_Kinematics

# Register Kinematics in _limb_py:
_limb_py.Kinematics_swigregister(Kinematics)

UR3 = _limb_py.UR3
UR5 = _limb_py.UR5
UR10 = _limb_py.UR10
UR16e = _limb_py.UR16e

def forward(q: "double const *", T: "double *", ur_type: "int") -> "void":
    return _limb_py.forward(q, T, ur_type)

def inverse(T: "double const *", q_sols: "double *", q6_des: "double", ur_type: "int") -> "int":
    return _limb_py.inverse(T, q_sols, q6_des, ur_type)
class Dynamics(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _config = property(_limb_py.Dynamics__config_get, _limb_py.Dynamics__config_set)

    def __init__(self, *args):
        _limb_py.Dynamics_swiginit(self, _limb_py.new_Dynamics(*args))

    def calGravityTorqueKDL(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Dynamics_calGravityTorqueKDL(self, *args)

    def calMassMatrixKDL(self, q: "Eigen::VectorXd") -> "Eigen::MatrixXd":
        return _limb_py.Dynamics_calMassMatrixKDL(self, q)

    def calInverseDynamics(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Dynamics_calInverseDynamics(self, *args)
    __swig_destroy__ = _limb_py.delete_Dynamics

# Register Dynamics in _limb_py:
_limb_py.Dynamics_swigregister(Dynamics)

class WaypointPlanning(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cubic_spline_interpolation = property(_limb_py.WaypointPlanning_cubic_spline_interpolation_get, _limb_py.WaypointPlanning_cubic_spline_interpolation_set)
    waypoint_list = property(_limb_py.WaypointPlanning_waypoint_list_get, _limb_py.WaypointPlanning_waypoint_list_set)
    num = property(_limb_py.WaypointPlanning_num_get, _limb_py.WaypointPlanning_num_set)

    def __init__(self):
        _limb_py.WaypointPlanning_swiginit(self, _limb_py.new_WaypointPlanning())
    __swig_destroy__ = _limb_py.delete_WaypointPlanning

# Register WaypointPlanning in _limb_py:
_limb_py.WaypointPlanning_swigregister(WaypointPlanning)

class CubicSplineInterpolation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    flag = property(_limb_py.CubicSplineInterpolation_flag_get, _limb_py.CubicSplineInterpolation_flag_set)
    point_num = property(_limb_py.CubicSplineInterpolation_point_num_get, _limb_py.CubicSplineInterpolation_point_num_set)
    duration = property(_limb_py.CubicSplineInterpolation_duration_get, _limb_py.CubicSplineInterpolation_duration_set)
    cqi = property(_limb_py.CubicSplineInterpolation_cqi_get, _limb_py.CubicSplineInterpolation_cqi_set)
    cti = property(_limb_py.CubicSplineInterpolation_cti_get, _limb_py.CubicSplineInterpolation_cti_set)
    ai = property(_limb_py.CubicSplineInterpolation_ai_get, _limb_py.CubicSplineInterpolation_ai_set)
    bi = property(_limb_py.CubicSplineInterpolation_bi_get, _limb_py.CubicSplineInterpolation_bi_set)
    ci = property(_limb_py.CubicSplineInterpolation_ci_get, _limb_py.CubicSplineInterpolation_ci_set)
    di = property(_limb_py.CubicSplineInterpolation_di_get, _limb_py.CubicSplineInterpolation_di_set)
    h = property(_limb_py.CubicSplineInterpolation_h_get, _limb_py.CubicSplineInterpolation_h_set)
    A = property(_limb_py.CubicSplineInterpolation_A_get, _limb_py.CubicSplineInterpolation_A_set)
    B = property(_limb_py.CubicSplineInterpolation_B_get, _limb_py.CubicSplineInterpolation_B_set)
    C = property(_limb_py.CubicSplineInterpolation_C_get, _limb_py.CubicSplineInterpolation_C_set)
    D = property(_limb_py.CubicSplineInterpolation_D_get, _limb_py.CubicSplineInterpolation_D_set)
    E = property(_limb_py.CubicSplineInterpolation_E_get, _limb_py.CubicSplineInterpolation_E_set)
    M = property(_limb_py.CubicSplineInterpolation_M_get, _limb_py.CubicSplineInterpolation_M_set)

    def __init__(self):
        _limb_py.CubicSplineInterpolation_swiginit(self, _limb_py.new_CubicSplineInterpolation())
    __swig_destroy__ = _limb_py.delete_CubicSplineInterpolation

# Register CubicSplineInterpolation in _limb_py:
_limb_py.CubicSplineInterpolation_swigregister(CubicSplineInterpolation)

class WaypointList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    lenth = property(_limb_py.WaypointList_lenth_get, _limb_py.WaypointList_lenth_set)
    waypoint = property(_limb_py.WaypointList_waypoint_get, _limb_py.WaypointList_waypoint_set)
    time_list = property(_limb_py.WaypointList_time_list_get, _limb_py.WaypointList_time_list_set)

    def __init__(self):
        _limb_py.WaypointList_swiginit(self, _limb_py.new_WaypointList())
    __swig_destroy__ = _limb_py.delete_WaypointList

# Register WaypointList in _limb_py:
_limb_py.WaypointList_swigregister(WaypointList)

class Planning(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    online_trajectory_generation = property(_limb_py.Planning_online_trajectory_generation_get, _limb_py.Planning_online_trajectory_generation_set)

    def __init__(self, *args):
        _limb_py.Planning_swiginit(self, _limb_py.new_Planning(*args))
    __swig_destroy__ = _limb_py.delete_Planning

    def calCartesianSpacePlanning(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Planning_calCartesianSpacePlanning(self, *args)

    def calInterpolationPose(self, init: "Eigen::VectorXd", goal: "Eigen::VectorXd", scale: "double") -> "Eigen::VectorXd":
        return _limb_py.Planning_calInterpolationPose(self, init, goal, scale)

    def cubicPolynomialPlanning(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Planning_cubicPolynomialPlanning(self, *args)

    def jointSpacePlanning(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Planning_jointSpacePlanning(self, *args)

    def calDuration(self, init: "Eigen::VectorXd", goal: "Eigen::VectorXd") -> "double":
        return _limb_py.Planning_calDuration(self, init, goal)

    def cartesianSpacePlanning(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Planning_cartesianSpacePlanning(self, *args)

    def sphericalLinearInterpolation(self, starting: "Eigen::VectorXd", ending: "Eigen::VectorXd", t: "double") -> "Eigen::VectorXd":
        return _limb_py.Planning_sphericalLinearInterpolation(self, starting, ending, t)

    def calCubicSplineInterpolationInitList(self, *args) -> "void":
        return _limb_py.Planning_calCubicSplineInterpolationInitList(self, *args)

    def calCubicSplineInterpolationInitEigenList(self, waypoint_planning: "WaypointPlanning", waypoint_array: "vector_vector_double", time_list: "DoubleVector", slice: "double"=-1) -> "void":
        return _limb_py.Planning_calCubicSplineInterpolationInitEigenList(self, waypoint_planning, waypoint_array, time_list, slice)

    def calLinearPositionList(self, waypoint_planning: "WaypointPlanning", t: "double") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Planning_calLinearPositionList(self, waypoint_planning, t)

    def calCosinePositionList(self, waypoint_planning: "WaypointPlanning", t: "double") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Planning_calCosinePositionList(self, waypoint_planning, t)

    def calCubicPositionList(self, waypoint_planning: "WaypointPlanning", t: "double") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Planning_calCubicPositionList(self, waypoint_planning, t)

    def calCatmullRomPositionList(self, waypoint_planning: "WaypointPlanning", t: "double") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Planning_calCatmullRomPositionList(self, waypoint_planning, t)

    def calHermitePositionList(self, waypoint_planning: "WaypointPlanning", t: "double", tension: "double", bias: "double") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Planning_calHermitePositionList(self, waypoint_planning, t, tension, bias)

    def calCubicSplineInterpolationPositionList(self, waypoint_planning: "WaypointPlanning", t: "double") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Planning_calCubicSplineInterpolationPositionList(self, waypoint_planning, t)

    def calCubicSplineInterpolationSpeedList(self, waypoint_planning: "WaypointPlanning", t: "double") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Planning_calCubicSplineInterpolationSpeedList(self, waypoint_planning, t)

    def calCubicSplineInterpolationAccelerationList(self, waypoint_planning: "WaypointPlanning", t: "double") -> "std::vector< double,std::allocator< double > >":
        return _limb_py.Planning_calCubicSplineInterpolationAccelerationList(self, waypoint_planning, t)

    def cubicSplineInterpolationInit(self, num: "int", waypoint_list: "WaypointList", csi: "CubicSplineInterpolation") -> "void":
        return _limb_py.Planning_cubicSplineInterpolationInit(self, num, waypoint_list, csi)

    def getWaypointTimeStep(self, t: "double", waypoint_list: "WaypointList") -> "int":
        return _limb_py.Planning_getWaypointTimeStep(self, t, waypoint_list)

    def calLinearPosition(self, t: "double", waypoint_list: "WaypointList") -> "double":
        return _limb_py.Planning_calLinearPosition(self, t, waypoint_list)

    def calCosinePosition(self, t: "double", waypoint_list: "WaypointList") -> "double":
        return _limb_py.Planning_calCosinePosition(self, t, waypoint_list)

    def calCubicPosition(self, t: "double", waypoint_list: "WaypointList") -> "double":
        return _limb_py.Planning_calCubicPosition(self, t, waypoint_list)

    def calCatmullRomPosition(self, t: "double", waypoint_list: "WaypointList") -> "double":
        return _limb_py.Planning_calCatmullRomPosition(self, t, waypoint_list)

    def calHermitePosition(self, t: "double", waypoint_list: "WaypointList", tension: "double", bias: "double") -> "double":
        return _limb_py.Planning_calHermitePosition(self, t, waypoint_list, tension, bias)

    def sinAccPosition(self, start: "double", end: "double", duration: "int", t: "int") -> "double":
        return _limb_py.Planning_sinAccPosition(self, start, end, duration, t)

    def sinAccSpeed(self, start: "double", end: "double", duration: "int", t: "int") -> "double":
        return _limb_py.Planning_sinAccSpeed(self, start, end, duration, t)

    def cubicPolynomial(self, start_pos: "double", end_pos: "double", start_vel: "double", end_vel: "double", duration: "double", t: "double") -> "double":
        return _limb_py.Planning_cubicPolynomial(self, start_pos, end_pos, start_vel, end_vel, duration, t)

    def calLinear(self, scale: "double", y1: "double", y2: "double") -> "double":
        return _limb_py.Planning_calLinear(self, scale, y1, y2)

    def calCosine(self, scale: "double", y1: "double", y2: "double") -> "double":
        return _limb_py.Planning_calCosine(self, scale, y1, y2)

    def calCubic(self, scale: "double", y0: "double", y1: "double", y2: "double", y3: "double") -> "double":
        return _limb_py.Planning_calCubic(self, scale, y0, y1, y2, y3)

    def calCatmullRom(self, scale: "double", y0: "double", y1: "double", y2: "double", y3: "double") -> "double":
        return _limb_py.Planning_calCatmullRom(self, scale, y0, y1, y2, y3)

    def calHermite(self, scale: "double", y0: "double", y1: "double", y2: "double", y3: "double", tension: "double", bias: "double") -> "double":
        return _limb_py.Planning_calHermite(self, scale, y0, y1, y2, y3, tension, bias)

    def calCubicSplineInterpolationPosition(self, t: "double", csi: "CubicSplineInterpolation") -> "double":
        return _limb_py.Planning_calCubicSplineInterpolationPosition(self, t, csi)

    def calCubicSplineInterpolationSpeed(self, t: "double", csi: "CubicSplineInterpolation") -> "double":
        return _limb_py.Planning_calCubicSplineInterpolationSpeed(self, t, csi)

    def calCubicSplineInterpolationAcceleration(self, t: "double", csi: "CubicSplineInterpolation") -> "double":
        return _limb_py.Planning_calCubicSplineInterpolationAcceleration(self, t, csi)

    def CubicSplineInterpolationSetup(self, start_speed: "double", waypoint_list: "WaypointList", csi: "CubicSplineInterpolation") -> "void":
        return _limb_py.Planning_CubicSplineInterpolationSetup(self, start_speed, waypoint_list, csi)

    def TDMA(self, X: "double *", n: "int const", A: "double *", B: "double *", C: "double *", D: "double *") -> "void":
        return _limb_py.Planning_TDMA(self, X, n, A, B, C, D)

    def OTGControllersInit(self, *args) -> "void":
        return _limb_py.Planning_OTGControllersInit(self, *args)

    def OTGControllersUpdate(self, *args) -> "void":
        return _limb_py.Planning_OTGControllersUpdate(self, *args)

    def OTGControllersOutput(self, *args) -> "Eigen::VectorXd":
        return _limb_py.Planning_OTGControllersOutput(self, *args)

    def OTGControllersQuit(self, *args) -> "void":
        return _limb_py.Planning_OTGControllersQuit(self, *args)

    def calP4PathPlannerInitEigenList(self, *args) -> "p4::PolynomialSolver::Solution":
        return _limb_py.Planning_calP4PathPlannerInitEigenList(self, *args)

    def calP4PathPlanner(self, _now_time: "double", time_array: "DoubleVector", solution: "p4::PolynomialSolver::Solution const") -> "Eigen::VectorXd":
        return _limb_py.Planning_calP4PathPlanner(self, _now_time, time_array, solution)

    def jointPlanning(self, *args) -> "void":
        return _limb_py.Planning_jointPlanning(self, *args)

    def jointPlanningOTG(self, interface: "std::shared_ptr< Interface >", pos_des: "Eigen::VectorXd", scale: "double") -> "void":
        return _limb_py.Planning_jointPlanningOTG(self, interface, pos_des, scale)

    def endpointPlanning(self, *args) -> "bool":
        return _limb_py.Planning_endpointPlanning(self, *args)

# Register Planning in _limb_py:
_limb_py.Planning_swigregister(Planning)

class Control(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _limb_py.Control_swiginit(self, _limb_py.new_Control())
    __swig_destroy__ = _limb_py.delete_Control

# Register Control in _limb_py:
_limb_py.Control_swigregister(Control)

class Force(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _limb_py.Force_swiginit(self, _limb_py.new_Force())
    __swig_destroy__ = _limb_py.delete_Force

# Register Force in _limb_py:
_limb_py.Force_swigregister(Force)

class Calibration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self):
        _limb_py.Calibration_swiginit(self, _limb_py.new_Calibration())
    __swig_destroy__ = _limb_py.delete_Calibration

# Register Calibration in _limb_py:
_limb_py.Calibration_swigregister(Calibration)

class Interface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _interfaceBase = property(_limb_py.Interface__interfaceBase_get, _limb_py.Interface__interfaceBase_set)
    _config = property(_limb_py.Interface__config_get, _limb_py.Interface__config_set)
    n = property(_limb_py.Interface_n_get, _limb_py.Interface_n_set)
    _controlMode = property(_limb_py.Interface__controlMode_get, _limb_py.Interface__controlMode_set)

    def __init__(self, node: "std::shared_ptr< ros::NodeHandle >", cfg: "std::shared_ptr< Config >"):
        _limb_py.Interface_swiginit(self, _limb_py.new_Interface(node, cfg))

    def createInterface(self) -> "std::shared_ptr< InterfaceBase >":
        return _limb_py.Interface_createInterface(self)
    __swig_destroy__ = _limb_py.delete_Interface

    def updateJointState(self) -> "void":
        return _limb_py.Interface_updateJointState(self)

    def setControlMode(self, mode: "enum ControlMode") -> "void":
        return _limb_py.Interface_setControlMode(self, mode)

    def getControlMode(self) -> "enum ControlMode":
        return _limb_py.Interface_getControlMode(self)

    def setJointPosition(self, pos: "Eigen::VectorXd") -> "bool":
        return _limb_py.Interface_setJointPosition(self, pos)

    def setJointVelocity(self, vel: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.Interface_setJointVelocity(self, vel)

    def setJointTorque(self, tor: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.Interface_setJointTorque(self, tor)

    def setJointCurrentTorque(self, tor: "Eigen::VectorXd") -> "Eigen::VectorXd":
        return _limb_py.Interface_setJointCurrentTorque(self, tor)

    def setEffectorJointPosition(self, pos: "Eigen::VectorXd") -> "void":
        return _limb_py.Interface_setEffectorJointPosition(self, pos)

    def setEffectorPosition(self, scale: "double") -> "void":
        return _limb_py.Interface_setEffectorPosition(self, scale)

    def setEffectorVelocity(self, scale: "double") -> "void":
        return _limb_py.Interface_setEffectorVelocity(self, scale)

    def setEffectorTorque(self, scale: "double") -> "void":
        return _limb_py.Interface_setEffectorTorque(self, scale)

    def setEffectorLimitPosition(self, scale: "double") -> "void":
        return _limb_py.Interface_setEffectorLimitPosition(self, scale)

    def setEffectorLimitVelocity(self, scale: "double") -> "void":
        return _limb_py.Interface_setEffectorLimitVelocity(self, scale)

    def setEffectorLimitForce(self, scale: "double") -> "void":
        return _limb_py.Interface_setEffectorLimitForce(self, scale)

    def setEffectorResetMode(self) -> "void":
        return _limb_py.Interface_setEffectorResetMode(self)

    def setEffectorBasicMode(self) -> "void":
        return _limb_py.Interface_setEffectorBasicMode(self)

    def setEffectorPinchMode(self) -> "void":
        return _limb_py.Interface_setEffectorPinchMode(self)

    def setEffectorWideMode(self) -> "void":
        return _limb_py.Interface_setEffectorWideMode(self)

    def setEffectorScissorMode(self) -> "void":
        return _limb_py.Interface_setEffectorScissorMode(self)

    def setEffectorOpenMode(self) -> "void":
        return _limb_py.Interface_setEffectorOpenMode(self)

    def setEffectorCloseMode(self) -> "void":
        return _limb_py.Interface_setEffectorCloseMode(self)

    def setEffectorMode(self, mode: "std::string", value: "double"=0) -> "void":
        return _limb_py.Interface_setEffectorMode(self, mode, value)

    def getEffectorState(self) -> "std::string":
        return _limb_py.Interface_getEffectorState(self)

    def getEffectorMode(self) -> "std::string":
        return _limb_py.Interface_getEffectorMode(self)

# Register Interface in _limb_py:
_limb_py.Interface_swigregister(Interface)

POSITION = _limb_py.POSITION
VELOCITY = _limb_py.VELOCITY
TORQUE = _limb_py.TORQUE
CURRENTTORQUE = _limb_py.CURRENTTORQUE
TRAJECTORY = _limb_py.TRAJECTORY
LIMIT_SET_POSITION_MODE = _limb_py.LIMIT_SET_POSITION_MODE
LIMIT_SET_VELOCITY_MODE = _limb_py.LIMIT_SET_VELOCITY_MODE
LIMIT_SET_FORCE_MODE = _limb_py.LIMIT_SET_FORCE_MODE
RESET_MODE = _limb_py.RESET_MODE
BASIC_MODE = _limb_py.BASIC_MODE
PINCH_MODE = _limb_py.PINCH_MODE
WIDE_MODE = _limb_py.WIDE_MODE
SCISSOR_MODE = _limb_py.SCISSOR_MODE
OPEN_MODE = _limb_py.OPEN_MODE
CLOSE_MODE = _limb_py.CLOSE_MODE
class InterfaceBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _config = property(_limb_py.InterfaceBase__config_get, _limb_py.InterfaceBase__config_set)
    n = property(_limb_py.InterfaceBase_n_get, _limb_py.InterfaceBase_n_set)
    controlState = property(_limb_py.InterfaceBase_controlState_get, _limb_py.InterfaceBase_controlState_set)

    def __init__(self, node: "std::shared_ptr< ros::NodeHandle >", cfg: "std::shared_ptr< Config >"):
        _limb_py.InterfaceBase_swiginit(self, _limb_py.new_InterfaceBase(node, cfg))

    def InterfaceBaseInit(self) -> "void":
        return _limb_py.InterfaceBase_InterfaceBaseInit(self)

    def InterfaceBaseJointStatesSubscriber(self, msg: "limb_core_msgs::JointState const &") -> "void":
        return _limb_py.InterfaceBase_InterfaceBaseJointStatesSubscriber(self, msg)

    def InterfaceBaseControllerSubscriber(self, msg: "limb_core_msgs::JointCommand const &") -> "void":
        return _limb_py.InterfaceBase_InterfaceBaseControllerSubscriber(self, msg)

    def interfaceController(self, *args) -> "void":
        return _limb_py.InterfaceBase_interfaceController(self, *args)

    def interfaceEffectorController(self, mode: "std::string") -> "void":
        return _limb_py.InterfaceBase_interfaceEffectorController(self, mode)

    def getJointPosition(self) -> "Eigen::VectorXd":
        return _limb_py.InterfaceBase_getJointPosition(self)

    def getJointVelocity(self) -> "Eigen::VectorXd":
        return _limb_py.InterfaceBase_getJointVelocity(self)

    def getJointTorque(self) -> "Eigen::VectorXd":
        return _limb_py.InterfaceBase_getJointTorque(self)

    def getJointCurrentTorque(self) -> "Eigen::VectorXd":
        return _limb_py.InterfaceBase_getJointCurrentTorque(self)

    def setJointPosition(self, pos: "Eigen::VectorXd") -> "void":
        return _limb_py.InterfaceBase_setJointPosition(self, pos)

    def setJointVelocity(self, vel: "Eigen::VectorXd") -> "void":
        return _limb_py.InterfaceBase_setJointVelocity(self, vel)

    def setJointTorque(self, tor: "Eigen::VectorXd") -> "void":
        return _limb_py.InterfaceBase_setJointTorque(self, tor)

    def setJointCurrentTorque(self, tor: "Eigen::VectorXd") -> "void":
        return _limb_py.InterfaceBase_setJointCurrentTorque(self, tor)

    def IsJointExecuting(self) -> "bool":
        return _limb_py.InterfaceBase_IsJointExecuting(self)

    def GetJointStatus(self) -> "limb_core_msgs::JointStatus":
        return _limb_py.InterfaceBase_GetJointStatus(self)
    position = property(_limb_py.InterfaceBase_position_get, _limb_py.InterfaceBase_position_set)
    velocity = property(_limb_py.InterfaceBase_velocity_get, _limb_py.InterfaceBase_velocity_set)
    effort = property(_limb_py.InterfaceBase_effort_get, _limb_py.InterfaceBase_effort_set)
    current_torque = property(_limb_py.InterfaceBase_current_torque_get, _limb_py.InterfaceBase_current_torque_set)
    zero = property(_limb_py.InterfaceBase_zero_get, _limb_py.InterfaceBase_zero_set)
    calEffort = property(_limb_py.InterfaceBase_calEffort_get, _limb_py.InterfaceBase_calEffort_set)
    __swig_destroy__ = _limb_py.delete_InterfaceBase

# Register InterfaceBase in _limb_py:
_limb_py.InterfaceBase_swigregister(InterfaceBase)

kSingle = _limb_py.kSingle
kLeft = _limb_py.kLeft
kRight = _limb_py.kRight
kArm = _limb_py.kArm
kEffector = _limb_py.kEffector

def GetTactileSensorLocations(component_type: "manipulator::component::Type", sensor_type: "drivers::tactile::TrxTactileSensorType") -> "std::vector< drivers::tactile::TrxTactileSensorLocation,std::allocator< drivers::tactile::TrxTactileSensorLocation > >":
    return _limb_py.GetTactileSensorLocations(component_type, sensor_type)

def GetTactileSensorTotalSize(component_type: "manipulator::component::Type", sensor_type: "drivers::tactile::TrxTactileSensorType") -> "int":
    return _limb_py.GetTactileSensorTotalSize(component_type, sensor_type)

def ToLocation(location: "std::string const &") -> "std::optional< manipulator::component::Location >":
    return _limb_py.ToLocation(location)

def ToType(type: "std::string const &") -> "std::optional< manipulator::component::Type >":
    return _limb_py.ToType(type)
class Limb(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def Create(root_path: "std::string const &", config_file_path: "std::string const &", wait_for_first_states_msg: "bool"=True) -> "std::shared_ptr< Limb >":
        return _limb_py.Limb_Create(root_path, config_file_path, wait_for_first_states_msg)
    _config = property(_limb_py.Limb__config_get, _limb_py.Limb__config_set)
    _interface = property(_limb_py.Limb__interface_get, _limb_py.Limb__interface_set)
    _interfaceBase = property(_limb_py.Limb__interfaceBase_get, _limb_py.Limb__interfaceBase_set)
    _transformer = property(_limb_py.Limb__transformer_get, _limb_py.Limb__transformer_set)
    _kinematics = property(_limb_py.Limb__kinematics_get, _limb_py.Limb__kinematics_set)
    _dynamics = property(_limb_py.Limb__dynamics_get, _limb_py.Limb__dynamics_set)
    _planning = property(_limb_py.Limb__planning_get, _limb_py.Limb__planning_set)
    _control = property(_limb_py.Limb__control_get, _limb_py.Limb__control_set)
    _force = property(_limb_py.Limb__force_get, _limb_py.Limb__force_set)
    _calibration = property(_limb_py.Limb__calibration_get, _limb_py.Limb__calibration_set)
    n = property(_limb_py.Limb_n_get, _limb_py.Limb_n_set)

    def __init__(self):
        _limb_py.Limb_swiginit(self, _limb_py.new_Limb())
    __swig_destroy__ = _limb_py.delete_Limb

    def Init(self) -> "bool":
        return _limb_py.Limb_Init(self)

    def InitTactile(self, config: "YAML::Node const &") -> "void":
        return _limb_py.Limb_InitTactile(self, config)

    def updateThread(self) -> "void":
        return _limb_py.Limb_updateThread(self)

    def update(self) -> "void":
        return _limb_py.Limb_update(self)

    def updateJointState(self) -> "void":
        return _limb_py.Limb_updateJointState(self)

    def updateEndpointState(self) -> "void":
        return _limb_py.Limb_updateEndpointState(self)

    def RequestStop(self) -> "void":
        return _limb_py.Limb_RequestStop(self)

    def IsJointExecuting(self) -> "bool":
        return _limb_py.Limb_IsJointExecuting(self)

    def GetTactileStateByTypeAndLocations(self, type: "drivers::tactile::TrxTactileSensorType", locations: "std::vector< drivers::tactile::TrxTactileSensorLocation,std::allocator< drivers::tactile::TrxTactileSensorLocation > > const &", zero_values_calibration: "bool"=False) -> "std::vector< int,std::allocator< int > >":
        return _limb_py.Limb_GetTactileStateByTypeAndLocations(self, type, locations, zero_values_calibration)

    def GetAllTactileStatesByType(self, type: "drivers::tactile::TrxTactileSensorType", zero_values_calibration: "bool"=False) -> "std::vector< int,std::allocator< int > >":
        return _limb_py.Limb_GetAllTactileStatesByType(self, type, zero_values_calibration)

    def GetTactilePressureStateZeroValues(self) -> "std::vector< int,std::allocator< int > >":
        return _limb_py.Limb_GetTactilePressureStateZeroValues(self)

    def SetTactilePressureZeroValues(self) -> "bool":
        return _limb_py.Limb_SetTactilePressureZeroValues(self)

    def MoveToSetTactilePressureZeroValues(self) -> "bool":
        return _limb_py.Limb_MoveToSetTactilePressureZeroValues(self)

# Register Limb in _limb_py:
_limb_py.Limb_swigregister(Limb)

def Limb_Create(root_path: "std::string const &", config_file_path: "std::string const &", wait_for_first_states_msg: "bool"=True) -> "std::shared_ptr< Limb >":
    return _limb_py.Limb_Create(root_path, config_file_path, wait_for_first_states_msg)

class LimbList(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    @staticmethod
    def CreateFromRosParameterServer(nh: "ros::NodeHandle &") -> "std::shared_ptr< LimbList >":
        return _limb_py.LimbList_CreateFromRosParameterServer(nh)

    def __init__(self, config_file_path: "std::string const &", wait_for_first_states_msg: "bool"=True):
        _limb_py.LimbList_swiginit(self, _limb_py.new_LimbList(config_file_path, wait_for_first_states_msg))

    def RequestStop(self) -> "void":
        return _limb_py.LimbList_RequestStop(self)

    def HasLimb(self, name: "std::string const &") -> "bool":
        return _limb_py.LimbList_HasLimb(self, name)

    def GetLimb(self, *args) -> "std::shared_ptr< Limb >":
        return _limb_py.LimbList_GetLimb(self, *args)

    def __getitem__(self, name: "std::string const &") -> "std::shared_ptr< Limb >":
        return _limb_py.LimbList___getitem__(self, name)

    def begin(self) -> "LimbList::Iterator":
        return _limb_py.LimbList_begin(self)

    def end(self) -> "LimbList::Iterator":
        return _limb_py.LimbList_end(self)

    def UpdateVisualObjectInfoAtEndpoint(self, id: "std::string const &", description: "std::string const &", mode: "LimbList::PerceptionMode", location: "std::optional< manipulator::component::Location >") -> "void":
        return _limb_py.LimbList_UpdateVisualObjectInfoAtEndpoint(self, id, description, mode, location)

    def UpdateVisualObjectInfoAtEndpointForPython(self, id: "std::string const &", description: "std::string const &", mode: "LimbList::PerceptionMode", location: "manipulator::component::Location") -> "void":
        return _limb_py.LimbList_UpdateVisualObjectInfoAtEndpointForPython(self, id, description, mode, location)

    def GetVisualObjectPoseFromPerception(self, id: "std::string const &", mode: "LimbList::PerceptionMode", location: "std::optional< manipulator::component::Location >", pose2base: "Eigen::VectorXd &") -> "bool":
        return _limb_py.LimbList_GetVisualObjectPoseFromPerception(self, id, mode, location, pose2base)

    def GetVisualObjectPoseFromPerceptionForPython(self, id: "std::string const &", mode: "LimbList::PerceptionMode", location: "manipulator::component::Location", pose2base: "Eigen::VectorXd &") -> "bool":
        return _limb_py.LimbList_GetVisualObjectPoseFromPerceptionForPython(self, id, mode, location, pose2base)

    def GetVisualObjectPoseFromVicon(self, id: "std::string const &", pose2torso: "Eigen::VectorXd &", time: "double *"=None) -> "bool":
        return _limb_py.LimbList_GetVisualObjectPoseFromVicon(self, id, pose2torso, time)

    def EnableRecordTrajectoryFromVicon(self, enable: "bool"=False) -> "void":
        return _limb_py.LimbList_EnableRecordTrajectoryFromVicon(self, enable)

    def GetObjectTrajectoryFromVicon(self, id: "std::string const &") -> "ObjectTraj":
        return _limb_py.LimbList_GetObjectTrajectoryFromVicon(self, id)

    def GetVicon2TorsoFrameTransformation(self) -> "std::optional< Eigen::Matrix4d >":
        return _limb_py.LimbList_GetVicon2TorsoFrameTransformation(self)
    __swig_destroy__ = _limb_py.delete_LimbList

# Register LimbList in _limb_py:
_limb_py.LimbList_swigregister(LimbList)

def LimbList_CreateFromRosParameterServer(nh: "ros::NodeHandle &") -> "std::shared_ptr< LimbList >":
    return _limb_py.LimbList_CreateFromRosParameterServer(nh)

class MetaBase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    _input = property(_limb_py.MetaBase__input_get, _limb_py.MetaBase__input_set)
    _limb_list = property(_limb_py.MetaBase__limb_list_get, _limb_py.MetaBase__limb_list_set)
    _limb_name = property(_limb_py.MetaBase__limb_name_get, _limb_py.MetaBase__limb_name_set)
    __swig_destroy__ = _limb_py.delete_MetaBase

    def initialize(self, *args) -> "void":
        return _limb_py.MetaBase_initialize(self, *args)

    def execute(self, loop: "bool") -> "std::string":
        return _limb_py.MetaBase_execute(self, loop)

    def RequestStop(self) -> "void":
        return _limb_py.MetaBase_RequestStop(self)

    def IsStopRequested(self) -> "bool":
        return _limb_py.MetaBase_IsStopRequested(self)

# Register MetaBase in _limb_py:
_limb_py.MetaBase_swigregister(MetaBase)

class ObjectTraj(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_limb_py.ObjectTraj_len_get, _limb_py.ObjectTraj_len_set)
    t = property(_limb_py.ObjectTraj_t_get, _limb_py.ObjectTraj_t_set)
    pose = property(_limb_py.ObjectTraj_pose_get, _limb_py.ObjectTraj_pose_set)

    def __init__(self):
        _limb_py.ObjectTraj_swiginit(self, _limb_py.new_ObjectTraj())
    __swig_destroy__ = _limb_py.delete_ObjectTraj

# Register ObjectTraj in _limb_py:
_limb_py.ObjectTraj_swigregister(ObjectTraj)

class ObjectTrajPredict(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    len = property(_limb_py.ObjectTrajPredict_len_get, _limb_py.ObjectTrajPredict_len_set)
    t = property(_limb_py.ObjectTrajPredict_t_get, _limb_py.ObjectTrajPredict_t_set)
    pose = property(_limb_py.ObjectTrajPredict_pose_get, _limb_py.ObjectTrajPredict_pose_set)

    def __init__(self):
        _limb_py.ObjectTrajPredict_swiginit(self, _limb_py.new_ObjectTrajPredict())
    __swig_destroy__ = _limb_py.delete_ObjectTrajPredict

# Register ObjectTrajPredict in _limb_py:
_limb_py.ObjectTrajPredict_swigregister(ObjectTrajPredict)

kLargeshaker = _limb_py.kLargeshaker
kSmallshaker = _limb_py.kSmallshaker
kWineglass = _limb_py.kWineglass
kLongneckbottle = _limb_py.kLongneckbottle
kMaxObjects = _limb_py.kMaxObjects
TargetMode_kVisualOnly = _limb_py.TargetMode_kVisualOnly
TargetMode_kTactileOnly = _limb_py.TargetMode_kTactileOnly
TargetMode_kVisualTactile = _limb_py.TargetMode_kVisualTactile
TargetMode_kVisualOnlyObjectInHand = _limb_py.TargetMode_kVisualOnlyObjectInHand
TargetMode_kMaxModes = _limb_py.TargetMode_kMaxModes
class TargetObjectGeometry(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    points_positions = property(_limb_py.TargetObjectGeometry_points_positions_get, _limb_py.TargetObjectGeometry_points_positions_set)
    points_normals = property(_limb_py.TargetObjectGeometry_points_normals_get, _limb_py.TargetObjectGeometry_points_normals_set)
    mesh_indices = property(_limb_py.TargetObjectGeometry_mesh_indices_get, _limb_py.TargetObjectGeometry_mesh_indices_set)

    def __init__(self):
        _limb_py.TargetObjectGeometry_swiginit(self, _limb_py.new_TargetObjectGeometry())
    __swig_destroy__ = _limb_py.delete_TargetObjectGeometry

# Register TargetObjectGeometry in _limb_py:
_limb_py.TargetObjectGeometry_swigregister(TargetObjectGeometry)
cvar = _limb_py.cvar
kNumOfPoseParameters = cvar.kNumOfPoseParameters
kNumOfJoints = cvar.kNumOfJoints
kNumOfBoxCorners = cvar.kNumOfBoxCorners

class TactilePixel(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    position = property(_limb_py.TactilePixel_position_get, _limb_py.TactilePixel_position_set)
    normal = property(_limb_py.TactilePixel_normal_get, _limb_py.TactilePixel_normal_set)
    pressure = property(_limb_py.TactilePixel_pressure_get, _limb_py.TactilePixel_pressure_set)
    is_valid = property(_limb_py.TactilePixel_is_valid_get, _limb_py.TactilePixel_is_valid_set)

    def __init__(self):
        _limb_py.TactilePixel_swiginit(self, _limb_py.new_TactilePixel())
    __swig_destroy__ = _limb_py.delete_TactilePixel

# Register TactilePixel in _limb_py:
_limb_py.TactilePixel_swigregister(TactilePixel)


def ToRosServiceObjectName(object: "perception::TargetObject") -> "char const *":
    return _limb_py.ToRosServiceObjectName(object)

def FromRosServiceObjectName(name: "std::string const &") -> "perception::TargetObject":
    return _limb_py.FromRosServiceObjectName(name)
TrxTactileSensorLocation_kPalm = _limb_py.TrxTactileSensorLocation_kPalm
TrxTactileSensorLocation_kThumbTip = _limb_py.TrxTactileSensorLocation_kThumbTip
TrxTactileSensorLocation_kIndexTip = _limb_py.TrxTactileSensorLocation_kIndexTip
TrxTactileSensorLocation_kMiddleTip = _limb_py.TrxTactileSensorLocation_kMiddleTip
TrxTactileSensorLocation_kThumbInner = _limb_py.TrxTactileSensorLocation_kThumbInner
TrxTactileSensorLocation_kIndexInner = _limb_py.TrxTactileSensorLocation_kIndexInner
TrxTactileSensorLocation_kMiddleInner = _limb_py.TrxTactileSensorLocation_kMiddleInner
TrxTactileSensorLocation_kForearm = _limb_py.TrxTactileSensorLocation_kForearm
TrxTactileSensorLocation_kMaxLocation = _limb_py.TrxTactileSensorLocation_kMaxLocation
TrxTactileSensorType_kPressure = _limb_py.TrxTactileSensorType_kPressure
TrxTactileSensorType_kOptical = _limb_py.TrxTactileSensorType_kOptical
TrxTactileSensorType_kLidar = _limb_py.TrxTactileSensorType_kLidar
TrxTactileSensorType_kProximity = _limb_py.TrxTactileSensorType_kProximity
class TrxSensorDimension(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    row = property(_limb_py.TrxSensorDimension_row_get, _limb_py.TrxSensorDimension_row_set)
    col = property(_limb_py.TrxSensorDimension_col_get, _limb_py.TrxSensorDimension_col_set)

    def __init__(self):
        _limb_py.TrxSensorDimension_swiginit(self, _limb_py.new_TrxSensorDimension())
    __swig_destroy__ = _limb_py.delete_TrxSensorDimension

# Register TrxSensorDimension in _limb_py:
_limb_py.TrxSensorDimension_swigregister(TrxSensorDimension)


def GetTrxSensorDimension(type: "drivers::tactile::TrxTactileSensorType", location: "drivers::tactile::TrxTactileSensorLocation") -> "drivers::tactile::TrxSensorDimension":
    return _limb_py.GetTrxSensorDimension(type, location)

def GetTrxSensorSize(type: "drivers::tactile::TrxTactileSensorType", location: "drivers::tactile::TrxTactileSensorLocation") -> "int":
    return _limb_py.GetTrxSensorSize(type, location)

def GetIgnoredElementIndices(type: "drivers::tactile::TrxTactileSensorType", location: "drivers::tactile::TrxTactileSensorLocation") -> "std::vector< int,std::allocator< int > >":
    return _limb_py.GetIgnoredElementIndices(type, location)


